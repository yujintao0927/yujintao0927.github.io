<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>ToService | yyjjjttao blog</title><meta name="keywords" content="Java, Lebron James, NBA"><meta name="author" content="Yu Jintao"><meta name="copyright" content="Yu Jintao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="ToService"><meta name="application-name" content="ToService"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="ToService"><meta property="og:url" content="https://yujintao0927.github.io/2025/12/24/ToService/index.html"><meta property="og:site_name" content="yyjjjttao blog"><meta property="og:description" content="面向服务的软件工程01 Services and Services System一、 服务的定义与本质“服务”是一个跨领域的核心概念，主要区别于有形的产品。可以从两个经典定义理解其核心特征：  James Fitzimmons: 服务是一种为客户（作为共同生产者）执行的、易逝的、无形的体验。强调无形"><meta property="og:locale" content="en"><meta property="og:image" content="https://yujintao0927.github.io/img/default_cover.jpg"><meta property="article:author" content="Yu Jintao"><meta property="article:tag" content="Java, Lebron James, NBA"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yujintao0927.github.io/img/default_cover.jpg"><meta name="description" content="面向服务的软件工程01 Services and Services System一、 服务的定义与本质“服务”是一个跨领域的核心概念，主要区别于有形的产品。可以从两个经典定义理解其核心特征：  James Fitzimmons: 服务是一种为客户（作为共同生产者）执行的、易逝的、无形的体验。强调无形"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://yujintao0927.github.io/2025/12/24/ToService/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"不要走！","backTitle":"欢迎回来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["大家好","我是于锦涛","I'm Yu Jintao","welcome everybody","enjoy yourself"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: Yu Jintao","link":"Link: ","source":"Source: yyjjjttao blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'yyjjjttao blog',
  title: 'ToService',
  postAI: '',
  pageFillDescription: '面向服务的软件工程, 01 Services and Services System, 一、 服务的定义与本质, 二、 服务与产品（制造）模型的对比, 三、 服务系统, 1. 定义, 2. 主要组成部分, 3. 多视角观察, 四、 IT赋能的服务, 1. 核心关系, 2. 主要模型, 3. IT服务与非IT服务的异同, 五、 服务生态系统与服务库存, 1. 服务生态系统概述, 2. 核心挑战, 02 Services Computing and Service-Oriented, 一、 软件范型的演进, 二、 面向服务（Service-Oriented）的核心概念, 1. 服务分层与分工, 2. 服务库存与服务组合, 三、 面向服务 vs. 面向对象, 1. 基本概念映射, 2. 设计原则的适用性, 四、 服务计算, 五、 关键技术概念与架构, 1. 面向服务的架构（SOA）, 2. 企业应用集成与业务流程管理, 3. 关键实现技术, 六、 面向服务总结, 03 Service-Oriented Architecture, 一、 SOA核心概念, 二、 SOA的优势, 三、 SOA的多层次视图, 四、 企业服务总线（ESB）, 五、 SOA参考架构（SOA-RA）, 1. 水平层（功能层）, 2. 垂直层（支撑层）, 六、 SOA实践与生命周期, 04 Message exchange and Data type, 一、 电子信息交换（Electronic Information Exchange）, 二、 XML (eXtensible Markup Language), 1. 核心特性, 2. 格式良好（Well-formed）XML, 3. 字符数据处理, 4. 格式良好 vs. 有效（Valid）, 三、 命名空间（NameSpace）, 1. 核心思想, 2. 关键概念, 四、 XML模式（XML Schema）, 1. 作用与特点, 2. 核心元素, 3. 模式定位, 五、 XPath, 1. 核心概念, 2. 路径表达式, 六、 扩展样式表语言家族（XSL）, 1. XSLT (XSL Transformations), 2. XPath, 七、 XML解析器, 1. DOM (Document Object Model) 解析器, 2. SAX (Simple API for XML) 解析器, 八、 数据表示标准化与服务合约, 05 Services modeling, 05.1 课程定位与演进, 05.2 SOAP Basis, 05.3 SOAP Extension, 05.4 SOAP Binding, 05.5 WSDL Basis, 05.6 WSDL InfoSet amp Component Model, 05.7 WSDL Interface amp Binding, 06 Web Services Publishing and Discovery, 1. Web服务发布概述, 2. UDDI (集中式注册), 3. UDDI 核心数据结构（重点）, 4. UDDI 发展, 5. UDDI API, 6. WSIL (分布式发现), 7. 服务发现, 8. JAXR (统一注册访问API), 07 Extension of Web Services, 1. WS-* 概述, 2. 复合服务, 3. BPEL (业务流程执行语言), 4. BPEL 核心概念与示例, 5. 消息分发与WS-Addressing, 6. 有状态服务与WSRF, 7. Web服务QoS (质量保障), 8. 安全 (WS-Security), 9. 事务与协调 (WS-Coordination), 10. 可靠消息传递 (WS-ReliableMessaging), 08 Service-Oriented Analysis, 面向服务分析的目标, 面向服务分析的流程, 以业务为核心的SOA, 常见业务分析方法, 业务服务的派生类型, 服务建模原则（部分关键原则）, 09 Service-Oriented Design, 面向服务设计的目标, 面向服务的设计过程, 组合SOA——选择服务层, 组合SOA——定位核心SOA标准, 组合SOA——选择SOA扩展, 设计服务, 设计以实体为核心的业务服务, 设计应用服务, 设计以任务为核心的业务服务, 设计面向服务的业务流程, 10 Principles of Service-Oriented Design, 10.1 Principles of Service-Oriented Design I, 面向服务设计的原则, 服务合约（标准化与设计）, 服务耦合（服务内及消费者依赖）, 10.2 Principles of Service-Oriented Design II, 服务抽象（信息隐藏与元抽象类型）, 服务可复用性（商业与无关设计）, 10.3 Principles of Service-Oriented Design III, 服务自治（处理边界与控制）, 服务无状态性（状态管理延迟与无状态性设计）, 10.4 Principles of Service-Oriented Design IV, 服务可发现性（可解释性与交流）, 服务可组合性（组合成员设计与复杂组合）, 11 Development Testing Deployment and management of Services, 服务的开发, 服务的测试, 服务的部署, 服务的管理, 12, 12.01 Web Services Platform Architecture, Web Services Platform Architecture, 12.02 JWS Architecture, JWS Architecture面向服务的软件工程一服务的定义与本质服务是一个跨领域的核心概念主要区别于有形的产品可以从两个经典定义理解其核心特征服务是一种为客户作为共同生产者执行的易逝的无形的体验强调无形性时间敏感性和客户参与共同生产服务是一系列或多或少的无形活动通常但不一定发生在客户与服务人员物理资源或服务提供者系统之间的互动中旨在为客户解决问题强调活动性互动性和问题解决导向核心总结服务是一种无形的过程性的需要消费者参与的活动或体验其生产与消费往往同时或几乎同时发生且无法被储存二服务与产品制造模型的对比为了清晰界定可以从属性上进行对比属性产品服务有形性有形物理对象无形过程或体验持久性可存储可跨时间转移易逝生产与消费同时所有权所有权可转移不涉及所有权转移是使用权的授予或能力的提供生产消费生产与消费分离生产与消费同时或几乎同时进行核心价值蕴含于实体中在交互过程中创造质量评估相对客观易于测量主观性强依赖于客户体验发展趋势现代经济中纯粹的制造在减少而服务行业包括物业管理安保维修软件开发外包等正在兴起同时出现了服务产品连续体许多实体产品也融合了增值服务如售后支持订阅制内容三服务系统服务系统是实现业务服务的软件系统在现代社会大量软件系统本质上都是服务系统定义服务系统可以被非正式地定义为一个六元组包含输入如客户需求原材料数据等输出交付给客户的服务结果或价值目标分为内部目标如效率利润和外部目标客户满意度转换将输入转换为输出的过程与逻辑组件构成系统的各个部分传感器用于监测系统内部状态和外部环境的机制主要组成部分服务人员设计开发测试运维人员等服务伙伴产业链上的合作伙伴客户服务的共同生产者有时是必要组成部分服务信息在系统中流动和处理的数据与知识服务活动具体的业务流程与操作服务基础设施资源包括物理资源如服务器资源如软件平台和抽象资源如品牌专利特性服务系统应是自包含和封装的具有明确的边界和接口多视角观察模型视角关注服务如何运作操作模型如何交付交付模型能力规划能力模型技术视角实现技术如传统软件技术服务网格计算自主计算等架构视角包括数据架构应用架构性能架构等优化视角运用运筹学复杂系统理论系统工程方法进行优化四赋能的服务当业务服务通过服务系统来提供时就构成了赋能的服务它代表了一种基于关系的交互旨在实现特定的业务目标核心关系涉及至少一个服务提供者和一个服务消费者之间的互动主要模型服务运营模型端到端模型服务商提供完整解决方案托管服务模型服务商托管和管理设施应用业务流程外包将特定业务流程外包以数据为中心的外包数据处理与管理服务在线经纪代理服务平台连接提供者与消费者服务计费模型可多级组合免费模式基于费用的模式政府服务模式公共财政支持服务与非服务的异同共同点遵循相似的服务生命周期拥有相似的服务系统要素主要区别关键绩效指标服务更侧重技术指标如可用性响应时间非服务更侧重业务结果需求管理服务需求更结构化可技术化非服务需求更灵活主观变化速度服务因技术迭代而变更更快五服务生态系统与服务库存服务生态系统概述从消费者视角看众多可以同时且独立使用的服务被称为垂直服务按行业划分如金融医疗垂直服务可分为纯服务和赋能的业务服务为了高效构建垂直服务可以复用一些跨行业的通用服务模块这些模块被称为水平服务水平服务可分为通用业务服务如支付身份验证和基础服务如计算存储服务生态系统就是由这些相互关联相互依赖的垂直服务和水平服务共同构成的复杂网络核心挑战如何利用有限资源构建和维护一个恰当的服务系统集合服务库存进而形成一个健康可持续的服务生态系统这正是面向服务的软件工程需要解决的根本问题一软件范型的演进软件开发经历了不同范型的演变以应对不断增长的复杂性软件危机与软件工程为了解决需求不明确规模大复杂度高服务系统问题尤为突出的困境软件工程应运而生关注软件过程方法工具及产品线过程式命令式范型直接抽象冯诺依曼计算机的顺序执行机制以程序状态和状态改变语句描述计算复用主要通过过程实现面向对象范型以封装了数据和操作的对象以及对象间的消息传递来描述计算核心是封装继承多态强调为变化而设计通过设计模式等手段提高灵活性基于构件的范型构件模块化可部署可替换的软件组成部分封装内部实现对外提供统一接口核心活动构件的创建管理以及复用已有构件组装应用与面向对象的区别构件强调二进制级的复用和黑盒组装接口标准更严格面向对象更多是源代码级的复用和设计面向服务范型服务自治开放自描述与实现无关的网络构件核心活动服务的创建管理以及复用已有服务通过网络组装应用目标应对服务系统带来的全新挑战复杂性灵活性外包模式技术与业务鸿沟等二面向服务的核心概念服务分层与分工水平服务与功能相关相对简单稳定由专家开发如支付服务身份验证服务垂直服务流程与具体应用业务流程相关复杂多变由业务专家设计可以通过服务进行包装和实现分工协作业务专家用稳定的水平服务来组装编排多变的垂直业务流程服务库存与服务组合服务库存一个在特定边界如一个企业或部门内经过独立标准化和治理的互补的服务集合分层结构通常按服务模型分层例如编排服务层业务服务层应用服务层蓝图先行在构建前需要先设计好服务库存蓝图服务组合为完成特定业务任务或流程将多个服务组装在一起形成的自动化解决方案龙卷风模型形象地展示了服务被多个不同的服务组合所共享和调用的场景体现了服务的可重用性三面向服务面向对象基本概念映射对象类服务服务合约面向服务强调无状态基于合约的交互而不是封装了状态的对象一个服务风格的类可能没有属性状态只有通过服务合约定义的能力接口服务合约服务合约的范围更广不仅定义了技术接口还可能包含服务质量业务策略等语义信息设计原则的适用性完全适用抽象封装服务内部实现被封装对外暴露合约单一职责原则服务应具有内聚的明确的业务功能委托关联组合聚合这些关系在服务组合中依然存在部分适用不强调继承泛化特化服务更倾向于通过组合和合约版本化来扩展功能而非类继承多态在服务中表现为通过标准化合约实现不同服务提供者的互换性开放封闭原则对于服务合约尤其重要修改合约需谨慎避免破坏现有消费者但服务实现可以开放扩展别重复你自己是构建可复用服务库存的核心驱动力四服务计算服务计算又称面向服务计算是一个多维度定义的新计算范式从计算范型看是一种以服务为基本构造块支持在异构环境中快速低成本简易组合分布式应用的新范式从软件架构看是在面向服务架构中进行计算的一套概念原则和方法核心是基于独立组件服务具有标准接口构建应用从服务本身看服务计算的使命是弥合业务服务与服务的鸿沟并最终增强业务服务涵盖了利用计算和技术对业务服务进行建模创建运营和管理的科学与技术从软件工程看服务计算涵盖了以服务为基本抽象采用工程化方法进行服务系统的分析设计开发测试部署管理等全生命周期活动的理论技术和方法例如面向服务的分析设计实现等五关键技术概念与架构面向服务的架构定义是一种以业务为中心的架构方法它将业务整合为一系列可链接可重复的业务任务即服务它帮助构建复合应用这些应用整合企业内部及外部的多个功能源来支持横向业务流程核心一套用于设计和开发可互操作服务的原则和方法论服务是定义良好的业务功能组件可被不同目的重用三角操作模型涉及服务提供者发布接口服务注册中心查询接口和服务消费者目标实现复杂软件系统的互操作性和集成架起与业务需求的桥梁企业应用集成与业务流程管理企业应用集成集成多个独立开发技术可能不兼容的应用的重要应用领域常使用企业服务总线作为集成基础架构业务流程管理将业务流程视为组织的战略资产进行理解管理和优化在中流程可以被定义管理使用和编排为服务即服务组合关键实现技术服务一种流行的实现技术栈核心标准包括基于的消息传递协议用于描述服务操作的格式语言服务合约在服务中通常由定义但合约概念更广服务遵循风格约束无状态统一接口通常使用方法每个资源有唯一标识通过交换资源表征来操作资源与基于的服务相比通常更轻量更易于集成六面向服务总结解决方案逻辑被实现为服务和服务组合其设计遵循面向服务的设计原则服务组合与复用一个服务组合由多个服务组装而成用于自动化特定业务任务由于服务被设计为通用的企业资源同一个服务可以被多个消费者程序调用参与不同的服务组合服务库存的价值标准化的服务集合形成服务库存可以在其物理部署环境中独立管理多个业务流程可以通过从现有服务库存中抽取通用服务来创建服务组合实现自动化的角色面向服务架构是一种经过优化的技术架构形式旨在为服务服务组合和服务库存提供最佳支持一核心概念是从架构视角支持服务计算整体范式的基础架构模型本质一种业务与对齐的方法应用依赖于可用的服务来支撑业务流程核心元素服务服务是自包含可重用的软件组件由服务提供者提供被服务请求者消费三角操作模型是的核心交互模式包含服务提供者发布服务接口服务注册中心提供服务查询接口服务消费者查找并绑定服务二的优势视角松耦合与复用通过标准接口消除对特定语言平台厂商时间访问地址和协议的依赖灵活支持服务的间接寻址和动态绑定业务视角保护投资提升现有资源利用率促进复用提高敏捷性快速响应业务变化支持外包便于整合外部服务三的多层次视图在四个层次上提供指导架起业务与的桥梁编程层指导底层技术如协议服务组件架构中间件层指导通用产品开源软件的设计开发如选择单多消息或事件驱动的基础设施流程层指导业务流程集成管理和事件驱动架构设计企业层指导企业组件化和高层转型咨询帮助企业决策如何用服务包实现流程四企业服务总线是实现的关键基础设施概念一种软件基础设施促进服务组件的动态集成消息路由中介和控制类比类似于的对象总线或的应用服务器但集成的是服务核心功能集成消息路由协议数据转换服务管理高级功能服务发现与供应基于性能动态调整高级服务发现特定技术适配器五参考架构是一个分层架构模板用于指导解决方案的整体设计水平层功能层分为服务提供者层后端和服务消费者层前端操作系统层包含现有的打包应用定制应用和遗留系统服务组件层实现服务接口的代码容器它依赖下层操作系统的功能并向上暴露为服务负责输入转换和输出适配服务层服务的逻辑管理层负责服务注册发现绑定接口聚合和生命周期管理包含服务集群的概念业务流程层处理服务组合与分解的所有业务逻辑通过组合服务来协调业务流程以满足客户需求组合方式主要有编排集中控制和编舞分布式协调消费者层负责表示层快速构建用户界面以使用下层服务支持多种用户渠道和缓存垂直层支撑层集成层解决方案的关键使能层提供中介路由和转换服务请求的能力是其典型代表服务质量层提供解决方案级的管理如可用性可靠性安全性提供监控管理机制数据架构层提供统一的数据表示和集成框架如电信业的模型治理层提供设计指导确保解决方案架构的合理设计建立最佳实践和原则六实践与生命周期服务导向建模与架构一种应用的实践方法包括三个步骤服务识别服务规约服务实现服务生命周期从服务构思到不再使用的全过程建模使用概念建模技术如自顶向下分解设计服务开发使用任何编程语言实现服务涵盖设计编码测试部署发布与发现通过发布订阅模型实现调用消费者与提供者协商后通过等协议远程调用组合使用等将一组可用服务组合成业务流程协作在复杂流程中协调多个不同提供者的服务涉及信息交换与协作监控与管理监控服务执行进行访问控制性能监控执行和异常处理在分布式多参与方环境中进行数据分析以持续改进本章主要讲解服务计算中实现数据交换与处理的基础技术栈核心是及其相关标准这些技术是服务之间进行结构化标准化通信的基石一电子信息交换电子信息交换是指在不同软件单元之间为执行业务功能而进行的电子编码信息移动交换场景应用内同一应用不同部分之间应用间同一公司系统内的不同应用之间系统间同一公司内的不同系统之间公司间不同公司之间核心挑战在异构环境中如何确保信息能被所有参与方无歧义地理解和正确处理这需要标准化的数据格式和协议二是服务计算中的元语言用于描述和交换结构化数据核心特性纯文本独立于平台和语言自描述性通过标签和属性描述数据结构可扩展性允许用户自定义标签格式良好必须遵循以下规则单一根元素文档有且仅有一个根元素标签规则起始标签必须有对应的结束标签空元素可用正确嵌套元素必须正确嵌套内层元素必须在外层元素结束前结束命名规则名称以字母下划线或冒号开头区分大小写不能包含空格不能以开头属性规则属性值必须用引号括起单双引号均可同一元素内属性名必须唯一声明可选通常位于文档首行如注释与处理指令注释为处理指令为字符数据处理解析字符数据解析器会解析其中的实体引用如代表不解析的字符数据用于包含可能被误解析为的文本块格式为格式良好有效格式良好符合基本语法规则所有解析器都会检查有效不仅格式良好还符合特定模式定义如或需要验证解析器检查三命名空间用于解决文档中元素和属性名冲突的问题特别是合并来自不同来源的时核心思想为每个名称元素属性附加一个全局唯一的作为限定符从而形成两段式名称前缀映射使用声明命名空间将前缀如映射到如限定名使用如来表示一个完整无歧义的名称关键概念默认命名空间使用声明作用于该元素及其所有未加前缀的子元素但不作用于属性作用域命名空间声明在其所在元素及其所有后代元素中有效除非被覆盖重置使用可以清除默认命名空间四模式用于定义文档的结构和数据类型是服务合约中数据定义的核心技术作用与特点数据验证比更强大支持丰富的数据类型和约束命名空间支持与命名空间紧密集成自身也是使用语法编写便于工具处理核心元素元素声明指定数据类型指定出现次数默认表示无限简单类型复杂类型简单类型不能包含子元素或属性如字符串整数可通过添加约束面如复杂类型可包含子元素和或属性组合器元素必须按指定顺序出现元素中只能出现一个元素必须全部出现但顺序不限属性声明全局与局部全局定义顶级元素可被重用局部定义嵌套仅用于特定位置模式定位在实例文档中通过属性关联模式和命名空间五一种用于在文档中导航和查询节点的语言是和的基础核心概念节点文档中的元素属性文本等都被视为节点轴定义了相对于当前节点的搜索方向如节点测试指定要选择的节点类型如谓词在方括号内用于过滤节点集如路径表达式绝对路径以开头从根节点开始相对路径从当前节点开始缩写语法表示文档中任意位置的节点表示当前节点表示父节点六扩展样式表语言家族用于文档的转换和格式化用于将文档转换为其他文档或纯文本声明式无副作用基于模板规则不依赖执行顺序核心处理流程读取源文档构建源树应用样式表中的模板规则生成结果树序列化结果树输出最终文档关键元素定义模板规则指示处理器处理当前节点的子节点提取并输出节点值循环处理节点集条件处理排序动态生成元素和属性如前所述重度依赖进行节点定位和匹配七解析器用于读取处理文档的程序组件解析器工作原理一次性将整个文档加载到内存构建成一个树形结构节点树特点优点可以随机访问和修改文档的任何部分缺点内存消耗大不适合处理超大文件应用场景需要对文档进行频繁复杂操作如增删改查的场合解析器工作原理基于事件驱动解析器顺序读取文档遇到开始标签结束标签文本等事件时触发回调函数特点优点内存占用极小不构建整个树解析速度快缺点只能顺序访问无法随机修改编程模型相对复杂需要应用程序自己维护状态应用场景只需读取特别是大型文档内容过滤或简单转换的场合对性能要求高八数据表示标准化与服务合约在服务计算中上述技术的根本目的是实现数据表示标准化这是服务合约长期稳定和可复用的前提核心挑战如何定义学生信息教务医院公安局各有不同需求导致数据冗余或定义权冲突面向服务视角的解决方案优先使用官方发布的标准化的模式定义而不是为每个服务最小化定制数据结构这确保了跨服务跨组织交互时语义的一致性尽管可能带来一定冗余但换取了互操作性和长期演化的稳定性服务合约如依赖于这些标准的定义来描述其交换的数据类型课程定位与演进面向服务的架构一个概念层面的架构模型是实现模型的一种具体技术技术演进脉络基础定义使用定义了消息格式和数据结构消息传输引入作为一种标准的传输协议使不同平台和语言的应用程序能够通信服务描述引入一种基于的标准接口定义语言用于交换的调用信息地点方式能力高级建模对于更复杂的服务如复合服务带有非功能需求的服务可能需要额外的规范如来补充简介与历史定义是一个基于的用于在分布式环境中交换结构化信息的消息框架它独立于编程模型和底层协议不再是缩写中不再代表历史先驱成为事实标准推荐标准消息结构可选扩展机制传递控制信息头块必需承载主要的端到端信息消息体内容处理模型节点发送接收转发或处理消息的实体中介位于初始发送者和最终接收者路径上的节点可以处理检查插入删除转发消息头提供增值服务不规定头块的具体内容消息的路由方式等两种交互模式文档导向模式异步交互发送完整的文档远程过程调用模式同步请求响应交互模拟程序调用故障模型元素所有和应用级故障都必须通过此元素在中报告结构必需故障代码人类可读原因可选应用特定信息故障节点故障节点角色头当无法处理强制头块时在返回的消息的中使用此元素标识未被理解的头块与调用要素目标节点地址方法名参数输入输出返回值消息交换模式可选的头块数据与底层协议抽象独立于传输机制通常依赖绑定如绑定或自定义相关来实现请求响应的关联处理模型与属性存在于头块中的可选属性标识该头块的预期目标所扮演的角色标准化角色每个接收消息的节点都必须能够处理标为此角色的头块消息的最终接收者角色元素总是以此角色为目标没有节点应处理此头块内容默认角色如果头块没有属性则其目标角色默认为属性作用如果设置为则目标节点必须按照该头块的规范处理它否则必须生成一个故障此类头块称为强制头块元素没有此属性但必须被最终接收者处理属性问题默认情况下未被中介处理的目标头块非在转发前会被移除解决方案指示即使一个目标为中介但未被该中介处理的头块也应被转发给下游节点使用场景与结合用于在消息路径上引入新的可选功能中介转发中介基于接收到的消息中的头块语义或使用的将消息转发到另一个节点例如路由头块主动中介在转发前对消息进行额外处理例如加密部分消息添加时间戳头块插入新头块描述修改二进制数据传输优化传统方式将二进制数据编码为类型的字符缺点消息体积显著增加约编解码有处理开销消息传输优化机制核心思想避免对大块二进制内容进行编码实现基于使用包根部分包含修改后的信封使用元素作为二进制数据的占位符相关部分包含实际的二进制数据通过属性如进行链接要求原始的编码必须是规范形式以确保二进制值与字符表示之间的一一对应引用优化在消息中通过引用外部资源如图片适用于同一资源被多次引用的场景资源表示头块当不希望或无法通过解引用获取资源时可以使用头块将资源的表示或优化后的二进制表示直接携带在消息中绑定的任务定义描述如何使用某种底层协议如在节点间传递消息核心任务提供信息集的序列化表示以便传输并能无损重建可支持附加功能如压缩加密特性与模块特性两个节点间交互所需功能的规范如加密通道可靠传递由标识实现方式绑定原生支持底层协议直接提供如的请求响应关联模块在信封内通过头块实现应用直接实现消息交换模式请求响应两个相邻节点间双向交换一条消息响应一个非消息如请求后跟一个作为响应一部分的消息绑定重点使用方法特性限制为或两种模式请求响应主要用于创建或修改资源状态消息放在请求和响应的中响应主要用于安全幂等地获取资源表示请求返回一个消息无法在请求中携带头块架构兼容的使用建议安全信息检索应使用和响应资源标识应体现在请求中非安全操作或需要头块使用和请求响应同样建议将资源标识部分放在请求中参数可同时保留在中编码方案属性用于限定头块子元素等的序列化编码方案如编码编码选择编码方案的选择是应用特定的互操作性通过带外协商保证非规范可通过传输消息作为邮件正文或附件本质上是单向的依赖于邮件基础设施的投递状态通知请求和响应的关联需要在应用层实现基本概念与历史定义一种用于描述网络服务端点操作消息协议的格式常与和结合使用历史事实标准推荐标准主要学习文档结构核心组件定义定义消息的数据类型通常使用内联或导入的定义服务的抽象接口包含一组操作操作定义了消息类型和使用的消息交换模式为特定提供具体的消息格式和传输协议细节如指定一个服务支持的以及一个或多个访问该服务的端点每个端点引用一个具体的和网络地址目标命名空间作用类似于的目标命名空间用于唯一标识和区分文档中定义的组件要求应为绝对且最好可以解引用到描述该服务的权威文档信息集与组件模型信息集语言基于信息集定义一个文档即一个符合规范的元素信息项组件模型为了精确定义语义约束和含义在信息集之上抽象出一层组件模型如等组件约束和含义都在组件模型层面定义模块化与用于组装同一命名空间的多个文档效果是累积的用于声明对不同命名空间中组件的引用必须使用此机制来引用其他命名空间属性对处理器查找导入包含文档位置的提示非强制定义消息类型的最佳实践内联模式直接在元素内使用分离模式推荐将模式定义在单独的文件中在内使用导入便于跨多个文档复用关键区别直接放在下导入的模式对该文档可见放在内联的内导入的模式仅对该内联模式可见对该文档不可见放在内联的内包含的模式成为内联模式的一部分对该文档可见接口继承允许接口继承一个或多个其他接口的操作和故障定义故障在接口级别定义故障类型可在多个操作中重用故障类似于特殊的消息操作必需属性标识所使用的的可选属性标识定义操作时遵循的规则集如风格风格安全操作标记为表示该操作对客户端是安全的如查询便于基础设施进行优化如缓存消息引用包含元素通过与中的消息占位符关联通过属性指定消息内容模式消息交换模式定义抽象消息的顺序和基数预定义了种如等抽象性抽象了具体的消息类型时序同步异步单多通道等细节通过标识具有可扩展性绑定作用提供协议和编码细节指定如何发送接收消息实现通过的开放内容模型使用绑定扩展如绑定扩展绑定扩展来指定可重用绑定省略属性不指定操作级细节仅通过默认规则仅在从引用时才与特定接口关联绑定操作故障通过属性引用接口中定义的抽象操作故障并为其提供具体的绑定信息绑定扩展主要支持兼容定义了默认规则允许在接口级别指定绑定操作级别可覆盖必须为故障显式提供绑定信息绑定扩展支持和原生协议序列化默认输入序列化使用花括号在中指定如何将输入数据序列化到请求的路径部分末尾是否加决定剩余数据是放在查询字符串还是消息体中选择设计原则对安全操作使用可能改变资源状态的操作使用与联动如果接口操作标记为安全且绑定未显式指定方法则默认使用服务发布概述发布目的将部署在应用服务器上的服务注册到互联网上的服务注册中心以便被用户发现注册中心提供的信息服务名称提供商名称描述服务的文件等元数据而非服务的具体实现主要发布方式集中式注册发布到中心化的服务注册中心如分布式注册发布到分布式的服务注册表如集中式注册定义通用描述发现与集成为服务的发布和发现提供元服务支持对丰富元数据的查询存储信息以消息格式存储注册的服务描述信息分类类比电话簿白页基础联系信息名称地址等黄页基于分类法的业务服务信息行业产品服务地理位置绿页技术服务信息如何调用服务的技术细节核心数据结构重点包含五个主要元素用于分层描述服务信息描述服务提供商企业的基本信息名称描述联系方式包含标识符集如自定义的企业工商注册号和分类信息集按行业产品地域等分类描述企业提供的具体服务归属于一个包含服务名称描述以及指向技术绑定的列表描述如何调用服务的技术细节包含访问点即服务端点和指向的引用技术模型描述唯一的概念或结构是中的核心可重用组件最常见用途指向一个文档用于描述服务接口或绑定通过属性链接到文件也用于定义分类法标识符系统等通过中的来标识这是一个规范用于声明业务实体之间的关系如父子公司合作伙伴发展是当前主要版本强调支持企业内部服务基础设施和联邦控制而非高度分布式的公共注册新特性注册联盟发布者分配的键订阅数字签名支持改进的信息模型和发现功能等传输层使用交互模式请求响应两类查询用于搜索和读取注册中心数据浏览模式和下钻模式发布用于添加更新和删除注册中心数据涉及授权保存获取删除操作分布式发现核心思想将服务作为普通的文档文件发布到常规服务器上无需复杂的中心化注册设施工作原理文档通过元素直接引用文件或通过元素链接到其他文档从而形成链优势成本低复杂度低易于部署劣势发现依赖于链的起始点和遍历不如查询强大和系统化服务发现发现使用客户端如通过查询进行搜索搜索方向按业务服务服务类型进行查找可基于名称标识符分类等进行过滤发现本质上是迭代遍历链的过程定位起始文档解析文档获取其中列出的服务描述和链接跟随感兴趣的链接获取新的文档或重复步骤直到找到目标信息通常通过解析工具如实现统一注册访问定义用于访问多种注册中心如的标准作用提供统一的信息模型和多层抽象使客户端能用同一套接口访问不同的底层注册中心架构角色实现特定注册规范如服务器实现规范作为访问的门面使用访问提供的服务概述定义指除核心标准之外用于扩展服务功能的一系列标准规范的总称特点标准众多由不同的标准组织或公司制定涵盖了服务交互的各个方面复合服务需求背景为了复用和灵活性垂直业务服务可以由多个水平基础服务组合而成由活动服务实现构成的商业流程需要由复合服务来实现实现方式传统方式在编程环境中调用子服务再将整个程序单元封装为服务标准方式使用基于的流程描述语言如来标准化地描述服务组合业务流程执行语言目的将多个服务协调编排成一个完整的业务流程定义交互的状态和逻辑关键能力精确定义跨企业业务协议的行为包括数据依赖行为异常处理长时间运行交互等两种建模方式可执行流程建模参与方在业务交互中的实际行为抽象流程仅指定参与方之间相互可见的消息交换行为不暴露内部实现开发流程采用两阶段法先创建服务描述再创建业务流程核心概念与示例在中定义定义两个服务之间的会话关系关联到和角色在中定义建模业务流程与之交互的伙伴服务由定义其特征变量用于维护流程的状态数据和历史类型基于消息类型活动基本活动如接收请求回复响应调用伙伴服务结构化活动如顺序并发分支循环非确定性选择流程示例采购订单接收客户的采购订单依次或并行调用支付服务和物流服务向客户回复处理结果消息分发与问题本身不足以让接收者唯一标识应处理消息的服务实例尤其是在一个端点托管多个服务时解决方案规范核心机制在头中定义属性其值唯一标识消息类型接收方可据此进行消息分发为每种消息类型定义了默认的值其他功能端点引用描述一个服务端点包含地址端口类型服务名及自定义引用属性消息关联头块如用于在异步多消息交换中关联请求与响应有状态服务与无状态有状态服务无状态不维护上下文轻量级扩展性好容错性高有状态维护持久化信息以提供个性化更复杂的服务但需要更多编码和资源有状态服务建模服务资源框架核心规范定义和访问资源状态的属性管理资源状态的生命周期立即销毁或定时销毁定义基础故障类型对资源进行分组管理关联方式在的定义中通过属性关联到描述资源属性的服务质量保障主要涵盖四个类别的标准安全事务可靠消息传递资源生命周期管理安全目标解决传统和的不足为消息交换提供端到端的保护三大核心问题认证与授权确认用户身份和权限消息完整性确保消息在传输中未被篡改消息加密确保消息内容机密性实现方式通过在头中添加块包含用户名令牌用于基本身份验证二进制安全令牌携带证书等数字签名基于标准保证完整性和不可否认性加密数据基于标准保证机密性事务与协调目的为多参与方多消息的服务交互提供一个通用的启动和协调框架核心组件协调者服务提供激活注册协调协议服务管理协调任务协调上下文包含协调者服务的端点引用和任务标识随业务消息在参与方间传递协调类型原子事务用于短时属性的事务全有或全无适用于高信任域内业务活动用于长时间运行的业务事务允许应用业务逻辑处理异常操作立即生效通过补偿机制处理失败可靠消息传递目的确保消息的可靠交换保障的特性保证送达发送方未收到确认时会重发无重复通过消息唯一标识符去重顺序保证保证消息按发送顺序被处理基本原理基于发送确认模型通过头扩展和特定的故障代码来实现面向服务分析是面向服务软件工程中的一个核心阶段其目标是在服务生态系统中识别和定义需要构建的服务并明确每个服务应封装哪些逻辑面向服务分析的目标识别服务候选在业务流程中识别可被抽象为独立服务的逻辑单元定义服务操作候选为每个服务候选定义具体的操作接口分组与语境化将服务操作候选分组到逻辑上一致的服务候选中定义服务边界确保新定义的服务不与现有或已规划的服务重叠识别复用潜力评估服务候选和服务操作候选的可复用性定义合成模型初步定义服务之间的组合方式面向服务分析的流程面向服务分析遵循一个结构化流程通常包括以下关键步骤步骤描述分解业务流程将业务流程拆解为独立的步骤或活动识别业务服务候选逻辑从流程步骤中识别出适合封装为服务候选的逻辑排除手工步骤和不可封装的遗留逻辑抽象编排逻辑识别应由服务编排层处理的逻辑如业务规则条件逻辑异常处理等创建业务服务候选基于已识别的逻辑创建业务服务候选并考虑业务中立性提炼和应用面向服务原则应用如复用自治等原则优化服务设计识别服务候选组合设想通用业务场景识别服务之间的组合关系修订业务服务候选根据组合分析结果修订服务候选分析应用处理需求确定实现服务操作所需的应用逻辑评估其存在性开发需求和跨系统边界情况识别应用服务操作候选识别与业务流程上下文无关的应用级操作创建应用服务候选基于应用操作候选创建应用服务候选修订服务候选组合根据应用服务候选修订服务组合修订应用服务候选最终修订应用服务候选可选保存服务候选库存将服务候选和相关元数据保存到库存中供后续阶段使用以业务为核心的在面向服务分析中应以业务服务为核心而不是单纯的技术服务如业务服务能够隔离业务领域和应用领域的变化促进服务的复用和企业的敏捷性常见业务分析方法业务流程管理模型是组织业务分析的主要形式用于描述和优化业务流程实体模型遵循面向对象规范用于描述业务领域中的关键实体及其关系业务服务的派生类型类型特点来源分析工作量复用潜力以任务为核心的业务服务灵活性高针对特定业务流程用例模型流程定义较少有限以实体为核心的业务服务稳定性高不包含流程逻辑实体模型较多较高服务建模原则部分关键原则原则考虑逻辑的跨流程复用性原则考虑以任务为核心的服务在流程内的复用潜能原则注意与流程相关的依赖因素这些因素影响服务的灵活性和复用性原则应用服务应与业务无关支持跨应用复用原则以清晰的边界识别逻辑单元原则避免逻辑边界蔓延服务之间逻辑重叠原则以平衡的模型为目标综合考虑业务需求标准和业界约定原则创建和发布业务服务建模标准面向服务设计是将面向服务分析阶段产生的服务候选逻辑模型转化为具体的服务设计物理模型的过程并将这些服务装配到实现业务流程的抽象组合中面向服务设计的目标确定架构扩展的核心集合识别并选择支持架构所需的核心技术和标准设定架构的边界明确服务架构的边界和部署环境识别所需的设计标准制定和遵循一致的设计规范和标准定义抽象服务接口设计基于服务候选设计独立于实现细节的抽象服务接口如定义识别潜在的服务组合分析并设计服务之间的组合关系评估面向服务原则的支持确保设计符合面向服务原则如复用性自治性等探究当代特征的支持考虑并集成等现代标准与扩展面向服务的设计过程面向服务的设计是一个结构化的多步骤过程核心活动包括组合选择服务层结构定位核心标准选择扩展设计服务具体设计以实体为核心的业务服务应用服务以任务为核心的业务服务设计面向服务的业务流程将业务流程模型转化为可执行的服务编排如组合选择服务层在设计时需要讨论如何配置服务层主要考虑以下因素现有配置如果已有标准化的服务层则在其基础上进行设计必需的标准如果重新构建需明确所需的标准服务组合性能权衡灵活性与性能服务部署考虑分布式环境下的性能与冗余服务版本控制平衡接口稳定性与功能扩展业务服务与设计确保与企业模型保持一致业务服务维护考虑长期维护的便利性组合定位核心标准应遵循行业标准尤其是基本概要它定义了一组确保互操作性的核心服务标准例如等设计时需遵循基本概要中的设计准则例如信封中不应包含声明绑定元素应使用绑定等组合选择扩展根据项目需求选择性地引入扩展特征和标准如等以及业务流程执行语言设计服务服务设计过程需要针对不同类型的服务以实体为核心的业务服务应用服务以任务为核心的业务服务分别进行但遵循相似的结构化步骤一般包括审查现有服务定义消息类型提取抽象服务接口应用面向服务原则标准化并完善服务接口识别必要的处理底层应用逻辑最终形成完整的抽象服务定义文档设计以实体为核心的业务服务特点稳定性高基于实体模型复用潜力大设计步骤以雇员服务为例审查现有服务避免功能冗余定义消息类型设计定义请求响应消息结构如提取抽象服务接口在中定义或和引用类型应用面向服务原则确保设计支持复用性自治性无状态性和可发现性标准化并完善服务接口应用设计标准并确保符合基本概要识别必要的处理明确底层应用逻辑如访问账务系统或数据库形成最终定义整合所有部分完成抽象服务设计设计应用服务特点与业务无关支持跨应用复用设计步骤以文档转换服务为例审查现有服务避免冗余考虑第三方服务确认上下文确保操作候选分组合理提取初始的服务接口定义和操作应用面向服务原则重点确保通用性可复用性和自治性标准化并提炼服务接口遵循设计标准识别技术约束考虑性能安全性可用性遗留系统限制等形成最终定义设计以任务为核心的业务服务特点针对特定业务流程灵活性高复用性相对有限设计步骤以发票处理服务为例定义工作流逻辑基于业务流程如活动图定义执行路径提取服务接口根据工作流逻辑定义操作和消息应用面向服务原则重点考虑自治性和无状态性常通过文档风格传递状态标准化并完善服务接口遵循设计标准识别需要的处理确认所需调用的子服务如实体服务应用服务已存在或已设计形成最终定义通常复用其他服务的设计面向服务的业务流程目标是将业务流程模型如图转化为可执行的服务编排如脚本设计步骤以工单提交流程为例刻画交互场景基于工作流逻辑和可用服务设计定义流程的交互路径设计流程服务接口为流程本身定义接口一个启动操作形式化伙伴服务会话在参与流程的各服务中定义并在中定义和消息定义流程逻辑使用活动如等实现业务流程逻辑包括正常流和异常处理对应交互场景和简化流程可选优化定义面向服务设计的第一组核心原则旨在通过一系列指导方针来定义和塑造服务以确保服务能够有效支持面向服务架构的目标如提高互操作性联合性敏捷性并降低负担面向服务设计的原则面向服务设计包含以下八项核心原则它们共同作用以实现高质量的可持续的服务生态系统标准化服务合约服务必须遵循标准化的合约如进行描述以确保服务能力的一致表达和明确的服务上下文服务松散耦合服务之间特别是服务合约与其消费者之间应最小化依赖关系这包括减少技术功能和实现层面的耦合服务抽象应最小化服务元信息如实现细节的对外可用性服务合约应只暴露必要的信息隐藏内部复杂性服务可复用性服务应设计为通用的和可复用的其封装的逻辑和合约应支持跨多个业务流程的重复使用服务自治服务应具有独立的功能边界和运行时环境以最大化其对自身处理逻辑的控制权从而提高可靠性和行为可预测性服务无状态性服务应尽可能设计为无状态的将状态管理职责外化如交由客户端或数据库以增强可扩展性和资源利用率服务可发现性服务应通过充分的可交流的元数据如服务描述策略进行描述使其易于在服务注册库中被发现和理解服务可组合性服务应被设计为可被有效组合的构建块以支持构建复杂的组合式的业务流程服务合约标准化与设计标准化服务合约原则是所有原则的基础它要求使用形式化和标准化的合约如来定义服务作用建立服务交互的术语提供技术限制需求和语义信息影响其他设计原则如松散耦合抽象会直接影响合约的定位和设计关键实践服务功能描述的标准化统一中操作和消息的命名规范如动词名词服务数据表示的标准化采用集中化模式为关键业务实体如客户订单定义官方共享的避免服务间不必要的数据转换从而提高内在互操作性服务策略的标准化使用等标准来模块化地定义非功能性需求如安全可靠性服务耦合服务内及消费者依赖服务松散耦合原则强调减少服务解决方案各部分之间的依赖特别是在服务合约与其消费者之间耦合类型逻辑合约耦合服务逻辑依赖于服务合约合约优先设计的结果这是积极耦合允许在保持接口稳定的情况下更换底层实现合约逻辑耦合服务合约从现有实现逻辑如数据库自动生成这被视为反模式会导致紧密的技术和实现耦合限制服务演化合约技术耦合合约与特定通信技术如专有绑定限制了潜在消费者合约实现耦合合约中暴露了物理实现细节如服务器名文件路径将消费者与特定环境绑定合约功能耦合合约专为支持某个特定外部业务流程而设计降低了通用性消费者耦合类型消费者合约耦合消费者通过标准化的服务合约访问服务这是形成松散耦合关系的基础消费者实现耦合消费者绕过服务合约直接访问服务内部实现如数据库这应极力避免设计影响与粒度的关系耦合程度影响操作和数据的粒度选择过粗或过细的粒度都可能增加不必要的依赖或性能开销与服务模型的关系以实体为核心的服务天然与业务实体耦合但应与其他逻辑解耦应用服务可能带有实现耦合以任务为核心的服务可能存在有意的功能耦合主要目标通过合约集中化强制所有访问必须通过标准合约并结合标准化设计最大化消费者合约耦合同时最小化所有其他形式的消极耦合从而提高服务的独立性演化能力和复用潜力本部分涵盖面向服务设计的第二组核心原则侧重于服务的抽象与复用能力这些原则确保服务既能隐藏复杂性以支持长期演化又能最大化其价值服务抽象信息隐藏与元抽象类型服务抽象原则旨在平衡服务所发布的信息量既要提供足够的细节以使服务可被理解和使用又要隐藏不必要的内部信息以保护服务的演化能力并最小化与服务消费者之间的耦合核心目标避免不必要服务信息元信息或其他信息的扩散合约中发布的信息越多形成的消费者合约耦合就越深甚至可能间接导致消费者实现耦合抽象的元信息类型技术信息隐藏编程语言系统资源等底层技术细节允许自由地进行技术变更功能信息通过技术合约如仅暴露必要的服务能力程序逻辑信息故意对外界隐藏服务的内部设计规范和源代码细节服务质量信息通过策略文档等描述服务的行为限制和可靠性要求这部分信息通常需要选择性发布与服务设计的关系抽象封装封装定义了服务边界内的逻辑和资源抽象决定了这些被封装内容中有多少暴露给外部良好的抽象允许改变内部实现而不影响现有消费者抽象与粒度抽象倾向于减少合约中的细节约束粗粒度约束以给予服务所有者最大的演化自由但使用策略时可能暴露更多细节与服务模型以实体为核心的服务和应用服务通常能实现较高的抽象级别而以任务为核心的服务和编排服务由于与具体业务流程绑定抽象级别往往受限主要风险多消费者耦合需求不同消费者可能需要不同粒度的接口细节可通过合约反规范化提供多重接口人为误判过于抽象导致服务无法被理解过于具体导致消费者对实现作出假设安全与隐私需防止合约暴露敏感信息可根据环境内部外部调整抽象级别服务可复用性商业与无关设计服务可复用性原则倡导通过重复使用服务来最大化每个软件单元的价值其核心是设计通用的与业务无关的服务使其能够支持多个业务流程复用的层次从单一目的程序到多目的程序再到面向服务所倡导的高度无关的作为企业资产的可复用服务无关服务指那些与特定业务流程技术或应用平台保持中立无关的服务服务越无关其复用潜力就越大关键支撑模式服务库存蓝图规划服务库存的顶层结构以系统化地识别和定义无关服务逻辑集中化要求当解决方案需要某项功能时必须调用服务库存中指定的唯一的服务该服务是该功能的官方提供者这消除了功能冗余是复用和标准化的基础合约集中化要求所有服务访问必须通过其发布的标准化的合约进行逻辑集中化调用哪个服务和合约集中化如何调用服务结合是确保复用和互操作性的基石与服务设计的关系与服务建模在分析阶段就应考虑复用潜力精化服务候选使其更通用甚至定义超出当前业务流程需求的额外能力候选与粒度服务粒度倾向于细粒度服务更专注更易复用能力粒度需平衡粗粒度能力多合一更通用但可能带来不必要的数据处理细粒度能力更灵活但可能导致多次调用常需提供多重粒度版本数据约束粒度倾向于更粗的数据粒度和更少的详细验证约束以降低消费者使用门槛主要风险文化阻力项目团队可能不愿使用他人创建的服务或不愿投入额外精力构建可被他人复用的服务治理负担可复用服务作为共享资产需要更严格的生命周期管理版本控制和变更控制单点失效一个被广泛复用的关键服务若发生故障将影响多个业务流程需通过高可用设计缓解安全复杂性不同使用场景可能对同一服务提出不同的安全要求与敏捷交付的冲突构建高度可复用的服务需要更多前期分析和设计可能与追求快速交付的敏捷方法产生矛盾本部分涵盖面向服务设计的第三组核心原则侧重于服务的自治与状态管理这些原则直接影响服务的运行时质量可靠性和可扩展性服务自治处理边界与控制服务自治原则强调服务应作为独立的构成单元对其执行环境拥有高度的控制权以提升可靠性行为可预测性和性能自治类型运行时自治服务在执行时对自身处理逻辑和资源的控制级别高运行时自治带来更高的性能可靠性和可预测性设计时自治服务所有者修改和演化服务的自由度高设计时自治支持服务适应新需求和技术自治级别由低到高共享自治服务与其它应用共享底层资源如数据库自治性最低服务逻辑自治部分隔离服务拥有专用处理逻辑但共享数据存储等资源完全自治隔离服务拥有专有的逻辑和运行时环境包括数据库服务器达到最高级别的自治与服务设计的关系服务合约自治通过服务规范化消除功能重叠来保证这是实现其他级别自治的基础与服务模型实体服务作为核心可复用资产最应追求高自治级别甚至完全隔离应用服务可能因封装遗留系统而具有混合自治级别任务编排服务的自治性取决于其组合成员的集体自治性与粒度追求高自治性常导致服务能力被拆分到更专注更细粒度的服务中以隔离和控制关键资源主要风险范围误判一旦服务被部署到隔离环境错误定义的服务范围很难更改遗留系统封装封装的遗留逻辑常常无法定制会严重限制服务的自治性过高估计需求实现高自治如专用服务器成本高昂需仔细评估投资回报服务无状态性状态管理延迟与无状态性设计服务无状态性原则倡导服务应尽量不管理会话状态将状态管理职责委托给架构或延迟到必要时以最大化服务的可扩展性和资源利用率核心思想服务应尽可能保持无状态条件避免在内存中长时间保持活动特定的临时数据从而能快速释放资源以服务更多请求状态管理策略状态委托将状态数据交给调用方消费者管理状态延迟将状态数据临时存储到服务外部的共享的持久化介质中如状态数据库消息队列无状态性级别由低到高非延迟状态管理服务在整个活动期间保持所有状态数据完全有状态部分延迟状态管理服务能卸载部分状态数据减少内存占用完全架构状态管理延迟服务最大限度地利用外部存储延迟状态大部分时间处于无状态与服务设计的关系消息作为状态载体可以通过精心设计的消息包括头在服务间传递业务和上下文数据从而减轻服务的状态管理负担与服务模型实体应用服务应力争高度无状态并标准化状态数据的表示和传递方式任务编排服务由于其业务流程协调者的角色通常需要管理流程上下文因此常被设计为有状态的但应利用状态延迟机制来优化资源使用主要风险架构依赖引入外部状态存储如数据库会形成新的依赖需权衡其带来的好处性能开销在状态延迟和恢复过程中数据的存储检索和解析会引入额外的运行时开销实现复杂性支持灵活的状态延迟机制需要更复杂的设计编程和测试本部分涵盖面向服务设计的最后两组原则侧重于服务的可发现性与可组合性这些原则确保服务能够被有效定位理解并装配成更复杂的解决方案服务可发现性可解释性与交流服务可发现性原则要求服务应配备充分的元数据并使其易于被发现和理解以便在服务库存中定位能够满足特定自动化需求的服务核心概念发现基于统一元信息在服务库存中搜索和定位服务的过程可解释性被发现的服务的元信息目的能力能够被清晰理解的质量元信息类型功能性元数据描述服务能做什么通过标准化的服务合约和清晰的文档如服务概要来表达服务质量元数据描述服务表现如何如性能可用性策略等通过等表达发现类型设计时发现由开发设计人员手动在服务注册库中查找服务运行时发现由程序动态查询并绑定服务更复杂较少见与服务设计的关系平衡的挑战需在服务抽象隐藏信息和服务可发现性提供信息之间取得平衡关键信息必须发布但实现细节应隐藏与其他原则服务可发现性主要服务于服务可复用性和服务可组合性使潜在的复用和组合机会不被错过主要风险事后补充元数据在服务开发完成后才补充元数据通常质量较差应在设计阶段早期创建交流不畅由不擅长沟通的技术或业务人员单独创建的元数据可能难以被其他人理解服务可组合性组合成员设计与复杂组合服务可组合性原则要求服务被设计为有效的可重复使用的组合成员能够被组装成更复杂的服务组合以解决更大的业务问题它是面向服务计算的基石核心概念服务组合在设计时定义的为支持业务流程而将多个服务能力组装在一起的逻辑组合角色组合控制器位于组合顶端的服务负责协调工作流通常是任务服务或编排服务组合成员被控制器或其他成员调用的服务指定控制器专门设计为只能担任控制器角色的服务组合质量一个服务组合的整体质量如性能可靠性取决于其所有成员服务质量的集体度量组合控制器的自治性会受到其调用的自治性较低的成员的拖累与服务设计的关系与粒度粒度直接影响组合效率细粒度服务能力导致更多调用次数粗粒度数据导致网络传输量增大需要权衡与服务模型实体应用服务通常作为组合成员追求高可组合性任务服务可担任组合成员子控制器或指定控制器编排服务通常是复杂的长期的组合控制器与服务编排使用等编排语言能更灵活更声明式地定义复杂组合与其他原则的紧密联系可组合性高度依赖于其他所有原则的实现程度例如需要标准化合约以确保互操作需要松散耦合以减少组合约束需要高自治和无状态的成员来保证组合的效率和可靠性主要风险单点故障与性能瓶颈一个被广泛组合的关键服务如果失效或性能低下会拖累所有包含它的组合治理复杂度过度复用的服务一旦需要变更会影响到大量组合需要进行严格的变更影响分析和版本管理本章节介绍面向服务软件工程中服务分析设计之后的关键生命周期阶段开发测试部署与管理服务的开发在完成面向服务设计与服务建模后进入具体实现阶段实现方式开发定制服务使用特定编程语言如在特定平台如上从头开发服务逻辑包装遗留系统将现有遗留应用或系统的功能通过服务适配器封装成标准服务接口是集成旧有资产的关键手段构建应用系统开发全新的基于服务架构的应用程序主要平台与厂商等服务的测试服务测试面临独特挑战如消费者未知源码不可见等因此测试重点从代码转向规约测试关注点关键问题服务潜在访问者类型是否满足所有服务策略断言面对异常情况的表现服务描述等是否准确表达了语义是否遵循基本概要以确保互操作性服务组合与发现的简易程度新服务是否符合既有设计规范是否引入了架构不支持的新功能或需求面向服务测试的特点基于规约的测试主要依据公开的服务合约进行测试而非源码动态性测试关注服务在运行时的行为组合表现及异常处理协同测试强调服务提供者代理注册中心和消费者之间的协同验证与确认测试方法协同验证与确认多方协作的测试过程一种支持服务测试资产如测试用例可靠性模型发布排名与管理的框架服务的部署将开发测试完成的服务发布到运行环境需考虑架构性能集成与运维等部署关键问题分布与基础设施服务如何分布基础设施能否满足所有服务的处理需求集成影响新服务对现有服务和应用的影响复用服务定位如何定位和部署在多个解决方案中复用的服务中间件影响引入中间件对现有环境的影响版本管理新版本服务是否需要与旧版本并行部署安全与扩展所需的安全设置账号管理以及如何维护服务池以适应扩展需求遗留系统管理如何维护和监管封装了遗留系统的服务服务的管理服务上线后需要持续的管理和治理以确保其持续有效安全地运行管理关注点使用监管如何监控服务的使用情况性能和合规性版本控制如何管理服务描述文档的版本和变更消息跟踪如何跟踪和管理服务间的消息交换用于调试和审计性能监控如何检测和诊断性能瓶颈生命周期管理涵盖服务从部署运维到退役的全过程管理本章节介绍服务平台架构的核心组成部分这是理解服务如何被部署和调用的技术基础一个服务平台是一套使用特定编程语言如来调用和部署服务的工具集它包含服务器端组件通常打包在容器中如应用服务器和客户端组件通常作为访问服务的工具包任何服务平台都必须提供三个核心子系统调用子系统服务器端调用处理从传输层如接收请求预处理消息确定目标服务和操作分派到具体的类方法反序列化参数调用目标序列化返回结果并包装成响应处理异常并生成客户端调用创建实现服务端点接口的代理实例序列化参数为符合的包装成消息进行后处理通过传输层发送请求接收并处理响应序列化子系统核心功能在对象和元素之间进行序列化和反序列化映射策略定义了类如何映射到目标组件的规则称为类型映射序列化引擎需要一套映射策略来实现这些映射实现机制标准绑定由规范预定义类到的映射源码注解通过在类源码中添加注解如注解来自定义标准绑定算法式映射逻辑内嵌在序列化子系统的算法中如规则式通过独立于系统的映射规则文件如框架的映射文件来定义部署子系统核心功能提供将目标如一个类或配置为可通过消息调用的服务的工具主要职责部署目标到容器如部署无状态会话到容器映射操作到目标方法定义序列化上下文一组映射策略发布配置处理器以提供支持配置端点监听器部署描述符用于配置上述各种对象和依赖的文件随着配置复杂度增加管理变得困难常需可视化工具辅助本章节介绍服务架构这是基于标准的具体服务平台实现核心是和等规范是平台上构建服务的标准体系旨在简化开发和部署服务器端部署与调用流程部署将组件服务的服务器端视图打包为端点或端点规范定义了部署过程和打包结构生成与定制结构由的标准映射决定可通过注解进行定制注解定制风格注解定制表示注解定制细节端点监听部署时运行时会根据注解部署描述符读取配置并在指定部署一个端点监听器请求处理当请求到达时运行时提取参数运行时根据注解和标准绑定将反序列化为参数业务调用调用目标方法响应生成将返回值序列化为将其包装为响应并返回注处理器调用和异常处理在图中省略但实际存在客户端调用流程生成编译客户端应用前使用工具生成服务端点接口获取代理运行时通过类的实例获取的代理实例方法调用调用代理实例上的方法和会根据注解将参数序列化为请求处理器处理发送前调用配置的处理器进行预处理如可靠性安全发送与接收发送请求接收响应响应处理处理器后处理反序列化响应为对象作为方法返回值开发模式从开始先编写类通过添加等注解将其部署为服务平台自动生成最简单但生成的可能不符合特定标准从开始已有预定义的契约使用工具生成骨架开发者实现业务逻辑利于遵循标准契约从和开始需要将现有的类映射到现有的契约这是系统集成中最常见也最困难的场景工具对此支持有限常需通过包装器代码或复杂的注解映射来桥接易导致代码复杂和难以维护核心规范与权衡定义了调用子系统部分部署和序列化逻辑是的后继者定义了与之间的标准数据绑定简化了处理定义了用于服务部署的注解定义了服务在服务器上的部署架构和打包确保可移植性核心权衡通过标准映射和注解极大地简化了开发尤其是模式但牺牲了灵活性当需要将现有系统映射到严格定义的行业标准模式时工具支持不足可能无法生成有用的服务或迫使开发者编写繁琐的适配代码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-24 20:40:29',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 8.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://yyjjjttao-blog.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">Theme</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://docs.anheyu.com/" title="Anzhiyu"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="Anzhiyu"/><span class="back-menu-item-text">Anzhiyu</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">yyjjjttao blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Article</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> Tunnel</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> Classification</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> Label</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> My</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=5398569579&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> Music Hall</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> Album Set</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-equipment"></use></svg><span> Equiment</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/air-conditioner/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fan"></use></svg><span> Conditioning</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> About</span></a></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="Randomly redirected to a project website"><a class="site-page" onclick="anzhiyu.totraveling()" title="Randomly redirected to a project website" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="Randomly go to an article" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/James/" style="font-size: 1.05rem;">James<sup>1</sup></a><a href="/tags/basketball/" style="font-size: 1.05rem;">basketball<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">December 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/college/" itemprop="url">college</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">ToService</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-24T07:42:23.000Z" title="Created 2025-12-24 15:42:23">2025-12-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-24T12:40:29.025Z" title="Updated 2025-12-24 20:40:29">2025-12-24</time></span></div><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://yujintao0927.github.io/2025/12/24/ToService/"><header><a class="post-meta-categories" href="/categories/college/" itemprop="url">college</a><h1 id="CrawlerTitle" itemprop="name headline">ToService</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Yu Jintao</span><time itemprop="dateCreated datePublished" datetime="2025-12-24T07:42:23.000Z" title="Created 2025-12-24 15:42:23">2025-12-24</time><time itemprop="dateCreated datePublished" datetime="2025-12-24T12:40:29.025Z" title="Updated 2025-12-24 20:40:29">2025-12-24</time></header><h1 id="面向服务的软件工程"><a href="#面向服务的软件工程" class="headerlink" title="面向服务的软件工程"></a>面向服务的软件工程</h1><h2 id="01-Services-and-Services-System"><a href="#01-Services-and-Services-System" class="headerlink" title="01 Services and Services System"></a>01 Services and Services System</h2><h3 id="一、-服务的定义与本质"><a href="#一、-服务的定义与本质" class="headerlink" title="一、 服务的定义与本质"></a>一、 服务的定义与本质</h3><p>“服务”是一个跨领域的核心概念，主要区别于有形的产品。可以从两个经典定义理解其核心特征：</p>
<ul>
<li><strong>James Fitzimmons</strong>: 服务是一种为客户（作为共同生产者）执行的、易逝的、无形的体验。强调<strong>无形性、时间敏感性</strong>和<strong>客户参与（共同生产）</strong>。</li>
<li><strong>Christian Gronroos</strong>: 服务是一系列或多或少的无形活动，通常（但不一定）发生在客户与服务人员、物理资源或服务提供者系统之间的互动中，旨在为客户解决问题。强调<strong>活动性、互动性</strong>和<strong>问题解决导向</strong>。</li>
</ul>
<p><strong>核心总结</strong>：服务是一种<strong>无形的、过程性的、需要消费者参与</strong>的活动或体验，其生产与消费往往<strong>同时或几乎同时发生</strong>，且无法被储存。</p>
<h3 id="二、-服务与产品（制造）模型的对比"><a href="#二、-服务与产品（制造）模型的对比" class="headerlink" title="二、 服务与产品（制造）模型的对比"></a>二、 服务与产品（制造）模型的对比</h3><p>为了清晰界定，可以从属性上进行对比：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">产品 (Goods)</th>
<th align="left">服务 (Service)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>有形性</strong></td>
<td align="left">有形，物理对象</td>
<td align="left">无形，过程或体验</td>
</tr>
<tr>
<td align="left"><strong>持久性</strong></td>
<td align="left">可存储，可跨时间转移</td>
<td align="left">易逝，生产与消费同时</td>
</tr>
<tr>
<td align="left"><strong>所有权</strong></td>
<td align="left">所有权可转移</td>
<td align="left">不涉及所有权转移，是使用权的授予或能力的提供</td>
</tr>
<tr>
<td align="left"><strong>生产消费</strong></td>
<td align="left">生产与消费分离</td>
<td align="left">生产与消费同时或几乎同时进行</td>
</tr>
<tr>
<td align="left"><strong>核心价值</strong></td>
<td align="left">蕴含于实体中</td>
<td align="left">在交互过程中创造</td>
</tr>
<tr>
<td align="left"><strong>质量评估</strong></td>
<td align="left">相对客观，易于测量</td>
<td align="left">主观性强，依赖于客户体验</td>
</tr>
</tbody></table>
<p><strong>发展趋势</strong>：现代经济中，纯粹的制造在减少，而服务行业（包括物业管理、安保、维修、软件开发外包等）正在兴起。同时，出现了<strong>服务-产品连续体</strong>，许多实体产品也融合了增值服务（如售后支持、订阅制内容）。</p>
<h3 id="三、-服务系统"><a href="#三、-服务系统" class="headerlink" title="三、 服务系统"></a>三、 服务系统</h3><p>服务系统是实现业务服务的IT软件系统。在现代社会，大量软件系统本质上都是服务系统。</p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>服务系统可以被非正式地定义为一个<strong>六元组</strong>，包含：</p>
<ul>
<li><strong>输入</strong>：如客户需求、原材料、数据等。</li>
<li><strong>输出</strong>：交付给客户的服务结果或价值。</li>
<li><strong>目标</strong>：分为内部目标（如效率、利润）和外部目标（客户满意度）。</li>
<li><strong>转换</strong>：将输入转换为输出的过程与逻辑。</li>
<li><strong>组件</strong>：构成系统的各个部分。</li>
<li><strong>传感器</strong>：用于监测系统内部状态和外部环境的机制。</li>
</ul>
<h4 id="2-主要组成部分"><a href="#2-主要组成部分" class="headerlink" title="2. 主要组成部分"></a>2. 主要组成部分</h4><ul>
<li><strong>服务人员</strong>：设计、开发、测试、运维人员等。</li>
<li><strong>服务伙伴</strong>：产业链上的合作伙伴。</li>
<li><strong>客户</strong>：服务的共同生产者（有时是必要组成部分）。</li>
<li><strong>服务信息</strong>：在系统中流动和处理的数据与知识。</li>
<li><strong>服务活动</strong>：具体的业务流程与操作。</li>
<li><strong>服务基础设施资源</strong>：包括物理资源（如服务器）、IT资源（如软件平台）和抽象资源（如品牌、专利）。</li>
<li><strong>特性</strong>：服务系统应是<strong>自包含</strong>和<strong>封装</strong>的，具有明确的边界和接口。</li>
</ul>
<h4 id="3-多视角观察"><a href="#3-多视角观察" class="headerlink" title="3. 多视角观察"></a>3. 多视角观察</h4><ul>
<li><strong>模型视角</strong>：关注服务如何运作（操作模型）、如何交付（交付模型）、能力规划（能力模型）。</li>
<li><strong>技术视角</strong>：实现技术，如传统软件技术、<strong>Web服务&#x2F;SOA</strong>、网格计算、自主计算等。</li>
<li><strong>架构视角</strong>：包括数据架构、应用架构、性能架构等。</li>
<li><strong>优化视角</strong>：运用运筹学、复杂系统理论、系统工程方法进行优化。</li>
</ul>
<h3 id="四、-IT赋能的服务"><a href="#四、-IT赋能的服务" class="headerlink" title="四、 IT赋能的服务"></a>四、 IT赋能的服务</h3><p>当业务服务通过服务系统来提供时，就构成了 <strong>IT赋能的服务</strong>。它代表了一种基于关系的交互，旨在实现特定的业务目标。</p>
<h4 id="1-核心关系"><a href="#1-核心关系" class="headerlink" title="1. 核心关系"></a>1. 核心关系</h4><p>涉及至少一个<strong>服务提供者</strong>和一个<strong>服务消费者</strong>之间的互动。</p>
<h4 id="2-主要模型"><a href="#2-主要模型" class="headerlink" title="2. 主要模型"></a>2. 主要模型</h4><ul>
<li><strong>服务运营模型</strong>：<ul>
<li>端到端模型：服务商提供完整解决方案。</li>
<li>托管服务模型：服务商托管和管理IT设施&#x2F;应用。</li>
<li>业务流程外包：将特定业务流程外包。</li>
<li>以数据为中心的外包：数据处理与管理服务。</li>
<li>在线经纪代理服务：平台连接提供者与消费者。</li>
</ul>
</li>
<li><strong>服务计费模型</strong>（可多级组合）：<ul>
<li>免费模式</li>
<li>基于费用的模式</li>
<li>政府服务模式（公共财政支持）</li>
</ul>
</li>
</ul>
<h4 id="3-IT服务与非IT服务的异同"><a href="#3-IT服务与非IT服务的异同" class="headerlink" title="3. IT服务与非IT服务的异同"></a>3. IT服务与非IT服务的异同</h4><ul>
<li><strong>共同点</strong>：遵循相似的服务生命周期，拥有相似的服务系统要素。</li>
<li><strong>主要区别</strong>：<ul>
<li><strong>关键绩效指标</strong>：IT服务更侧重技术指标（如可用性、响应时间），非IT服务更侧重业务结果。</li>
<li><strong>需求管理</strong>：IT服务需求更结构化、可技术化；非IT服务需求更灵活、主观。</li>
<li><strong>变化速度</strong>：IT服务因技术迭代而变更更快。</li>
</ul>
</li>
</ul>
<h3 id="五、-服务生态系统与服务库存"><a href="#五、-服务生态系统与服务库存" class="headerlink" title="五、 服务生态系统与服务库存"></a>五、 服务生态系统与服务库存</h3><h4 id="1-服务生态系统概述"><a href="#1-服务生态系统概述" class="headerlink" title="1. 服务生态系统概述"></a>1. 服务生态系统概述</h4><p>从消费者视角看，众多可以同时且独立使用的服务被称为<strong>垂直服务</strong>（按行业划分，如金融、医疗）。</p>
<ul>
<li>垂直服务可分为：<strong>纯IT服务</strong> 和 <strong>IT赋能的业务服务</strong>。</li>
</ul>
<p>为了高效构建垂直服务，可以复用一些跨行业的通用服务模块，这些模块被称为<strong>水平服务</strong>。</p>
<ul>
<li>水平服务可分为：<strong>通用业务服务</strong>（如支付、身份验证）和 <strong>基础IT服务</strong>（如计算、存储）。</li>
</ul>
<p><strong>服务生态系统</strong>就是由这些相互关联、相互依赖的垂直服务和水平服务共同构成的复杂网络。</p>
<h4 id="2-核心挑战"><a href="#2-核心挑战" class="headerlink" title="2. 核心挑战"></a>2. 核心挑战</h4><p>如何利用有限资源，构建和维护一个恰当的<strong>服务系统集合（服务库存）</strong>，进而形成一个健康、可持续的服务生态系统？这正是面向服务的软件工程需要解决的根本问题。</p>
<h2 id="02-Services-Computing-and-Service-Oriented"><a href="#02-Services-Computing-and-Service-Oriented" class="headerlink" title="02 Services Computing and Service-Oriented"></a>02 Services Computing and Service-Oriented</h2><h3 id="一、-软件范型的演进"><a href="#一、-软件范型的演进" class="headerlink" title="一、 软件范型的演进"></a>一、 软件范型的演进</h3><p>软件开发经历了不同范型的演变，以应对不断增长的复杂性：</p>
<ol>
<li><strong>软件危机与软件工程</strong>：为了解决需求不明确、规模大、复杂度高（<strong>服务系统问题尤为突出</strong>）的困境，软件工程应运而生，关注软件过程、方法、工具及产品线。</li>
<li><strong>过程式&#x2F;命令式范型</strong>：直接抽象冯·诺依曼计算机的顺序执行机制，以<strong>程序状态和状态改变语句</strong>描述计算。复用主要通过“过程”实现。</li>
<li><strong>面向对象范型</strong>：以<strong>封装了数据和操作的对象</strong>以及对象间的<strong>消息传递</strong>来描述计算。核心是“封装、继承、多态”，强调为<strong>变化而设计</strong>，通过设计模式等手段提高灵活性。</li>
<li><strong>基于构件的范型</strong>：<ul>
<li><strong>构件</strong>：模块化、可部署、可替换的软件组成部分，封装内部实现，对外提供统一接口。</li>
<li><strong>核心活动</strong>：构件的创建、管理，以及<strong>复用已有构件组装应用</strong>。</li>
<li><strong>与面向对象的区别</strong>：构件强调<strong>二进制级</strong>的复用和黑盒组装，接口标准更严格；面向对象更多是源代码级的复用和设计。</li>
</ul>
</li>
<li><strong>面向服务范型</strong>：<ul>
<li><strong>服务</strong>：<strong>自治、开放、自描述、与实现无关的网络构件</strong>。</li>
<li><strong>核心活动</strong>：服务的创建、管理，以及<strong>复用已有服务（通过网络）组装应用</strong>。</li>
<li><strong>目标</strong>：应对服务系统带来的全新挑战（复杂性、灵活性、外包模式、技术与业务鸿沟等）。</li>
</ul>
</li>
</ol>
<h3 id="二、-面向服务（Service-Oriented）的核心概念"><a href="#二、-面向服务（Service-Oriented）的核心概念" class="headerlink" title="二、 面向服务（Service-Oriented）的核心概念"></a>二、 面向服务（Service-Oriented）的核心概念</h3><h4 id="1-服务分层与分工"><a href="#1-服务分层与分工" class="headerlink" title="1. 服务分层与分工"></a>1. 服务分层与分工</h4><ul>
<li><strong>水平服务</strong>：与<strong>功能相关</strong>，相对简单稳定，由<strong>IT专家</strong>开发（如支付服务、身份验证服务）。</li>
<li><strong>垂直服务&#x2F;流程</strong>：与<strong>具体应用&#x2F;业务流程</strong>相关，复杂多变，由<strong>业务专家</strong>设计，可以通过服务进行包装和实现。</li>
<li><strong>分工协作</strong>：业务专家用稳定的水平服务来组装、编排多变的垂直业务流程。</li>
</ul>
<h4 id="2-服务库存与服务组合"><a href="#2-服务库存与服务组合" class="headerlink" title="2. 服务库存与服务组合"></a>2. 服务库存与服务组合</h4><ul>
<li><strong>服务库存</strong>：一个在特定边界（如一个企业或部门）内，经过<strong>独立标准化和治理</strong>的、互补的服务集合。<ul>
<li><strong>分层结构</strong>：通常按服务模型分层，例如：编排服务层、业务服务层、应用服务层。</li>
<li><strong>蓝图先行</strong>：在构建前，需要先设计好<strong>服务库存蓝图</strong>。</li>
</ul>
</li>
<li><strong>服务组合</strong>：为完成特定业务任务或流程，将多个服务组装在一起形成的自动化解决方案。</li>
<li><strong>“龙卷风模型”</strong>：形象地展示了服务被多个不同的服务组合所共享和调用的场景，体现了服务的<strong>可重用性</strong>。</li>
</ul>
<h3 id="三、-面向服务-vs-面向对象"><a href="#三、-面向服务-vs-面向对象" class="headerlink" title="三、 面向服务 vs. 面向对象"></a>三、 面向服务 vs. 面向对象</h3><h4 id="1-基本概念映射"><a href="#1-基本概念映射" class="headerlink" title="1. 基本概念映射"></a>1. 基本概念映射</h4><ul>
<li><strong>对象&#x2F;类</strong> vs. <strong>服务&#x2F;服务合约</strong>：面向服务强调无状态、基于合约的交互，而不是封装了状态的对象。一个“服务风格”的类可能<strong>没有属性（状态）</strong>，只有通过<strong>服务合约</strong>定义的能力。</li>
<li><strong>接口</strong> vs. <strong>服务合约</strong>：服务合约的范围更广，不仅定义了技术接口，还可能包含服务质量、业务策略等语义信息。</li>
</ul>
<h4 id="2-设计原则的适用性"><a href="#2-设计原则的适用性" class="headerlink" title="2. 设计原则的适用性"></a>2. 设计原则的适用性</h4><ul>
<li><strong>完全适用</strong>：<ul>
<li><strong>抽象、封装</strong>：服务内部实现被封装，对外暴露合约。</li>
<li><strong>单一职责原则</strong>：服务应具有内聚的、明确的业务功能。</li>
<li><strong>委托、关联、组合&#x2F;聚合</strong>：这些关系在服务组合中依然存在。</li>
</ul>
</li>
<li><strong>部分适用&#x2F;不强调</strong>：<ul>
<li><strong>继承、泛化&#x2F;特化</strong>：服务更倾向于通过<strong>组合</strong>和<strong>合约版本化</strong>来扩展功能，而非类继承。</li>
<li><strong>多态</strong>：在服务中表现为通过标准化合约实现不同服务提供者的互换性。</li>
<li><strong>开放-封闭原则</strong>：对于服务合约尤其重要，修改合约需谨慎，避免破坏现有消费者；但服务实现可以开放扩展。</li>
<li><strong>别重复你自己</strong>：是构建可复用服务库存的核心驱动力。</li>
</ul>
</li>
</ul>
<h3 id="四、-服务计算"><a href="#四、-服务计算" class="headerlink" title="四、 服务计算"></a>四、 服务计算</h3><p>服务计算（又称面向服务计算，Services Computing&#x2F;SOC）是一个多维度定义的新计算范式：</p>
<ol>
<li><strong>从计算范型看</strong>：SOC是一种以<strong>服务</strong>为基本构造块，支持在异构环境中快速、低成本、简易组合分布式应用的<strong>新范式</strong>。</li>
<li><strong>从软件架构看</strong>：SOC是在<strong>面向服务架构（SOA）</strong> 中进行计算的一套概念、原则和方法，核心是基于独立组件服务（具有标准接口）构建应用。</li>
<li><strong>从服务本身看</strong>：服务计算的使命是<strong>弥合业务服务与IT服务的鸿沟</strong>，并最终增强业务服务，涵盖了利用计算和IT技术对业务服务进行建模、创建、运营和管理的科学与技术。</li>
<li><strong>从软件工程看</strong>：服务计算涵盖了以<strong>服务为基本抽象</strong>，采用<strong>工程化方法</strong>进行服务系统的分析、设计、开发、测试、部署、管理等全生命周期活动的理论、技术和方法。例如：面向服务的分析、设计、实现等。</li>
</ol>
<h3 id="五、-关键技术概念与架构"><a href="#五、-关键技术概念与架构" class="headerlink" title="五、 关键技术概念与架构"></a>五、 关键技术概念与架构</h3><h4 id="1-面向服务的架构（SOA）"><a href="#1-面向服务的架构（SOA）" class="headerlink" title="1. 面向服务的架构（SOA）"></a>1. 面向服务的架构（SOA）</h4><ul>
<li><strong>定义</strong>：SOA是一种<strong>以业务为中心</strong>的IT架构方法，它将业务整合为一系列可链接、可重复的业务任务（即服务）。它帮助构建<strong>复合应用</strong>，这些应用整合企业内部及外部的多个功能源来支持横向业务流程。</li>
<li><strong>核心</strong>：一套用于设计和开发<strong>可互操作服务</strong>的原则和方法论。服务是定义良好的业务功能组件，可被不同目的重用。</li>
<li><strong>三角操作模型</strong>：涉及<strong>服务提供者</strong>（发布接口）、<strong>服务注册中心</strong>（查询接口）和<strong>服务消费者</strong>。</li>
<li><strong>目标</strong>：实现复杂软件系统的<strong>互操作性</strong>和<strong>集成</strong>，<strong>架起IT与业务需求的桥梁</strong>。</li>
</ul>
<h4 id="2-企业应用集成与业务流程管理"><a href="#2-企业应用集成与业务流程管理" class="headerlink" title="2. 企业应用集成与业务流程管理"></a>2. 企业应用集成与业务流程管理</h4><ul>
<li><strong>企业应用集成（EAI）</strong>：集成多个独立开发、技术可能不兼容的应用。SOC&#x2F;EAI的重要应用领域，常使用<strong>企业服务总线（ESB）</strong> 作为集成基础架构。</li>
<li><strong>业务流程管理（BPM）</strong>：将业务流程视为组织的战略资产进行理解、管理和优化。在SOA中，<strong>流程可以被定义、管理、使用和编排为服务</strong>（即服务组合）。</li>
</ul>
<h4 id="3-关键实现技术"><a href="#3-关键实现技术" class="headerlink" title="3. 关键实现技术"></a>3. 关键实现技术</h4><ul>
<li><strong>Web服务</strong>：一种流行的SOA实现技术栈，核心标准包括：<ul>
<li><strong>SOAP</strong>：基于XML的消息传递协议。</li>
<li><strong>WSDL</strong>：用于描述服务操作的XML格式语言。</li>
<li><strong>服务合约</strong>：在Web服务中，通常由WSDL定义，但合约概念更广。</li>
</ul>
</li>
<li><strong>RESTful 服务</strong>：<ul>
<li>遵循<strong>REST</strong>风格约束：<strong>无状态</strong>、<strong>统一接口</strong>（通常使用HTTP方法：GET, POST, PUT, DELETE）、每个资源有<strong>唯一URI标识</strong>、通过交换资源表征来操作资源。</li>
<li>与基于SOAP的Web服务相比，通常更轻量、更易于Web集成。</li>
</ul>
</li>
</ul>
<h3 id="六、-面向服务总结"><a href="#六、-面向服务总结" class="headerlink" title="六、 面向服务总结"></a>六、 面向服务总结</h3><ol>
<li><strong>解决方案逻辑</strong>：被实现为<strong>服务</strong>和<strong>服务组合</strong>，其设计遵循<strong>面向服务的设计原则</strong>。</li>
<li><strong>服务组合与复用</strong>：一个服务组合由多个服务组装而成，用于自动化特定业务任务。由于服务被设计为通用的企业资源，<strong>同一个服务可以被多个消费者程序调用，参与不同的服务组合</strong>。</li>
<li><strong>服务库存的价值</strong>：标准化的服务集合形成<strong>服务库存</strong>，可以在其物理部署环境中独立管理。多个业务流程可以通过从现有服务库存中抽取通用服务来创建服务组合实现自动化。</li>
<li><strong>SOA的角色</strong>：面向服务架构是一种经过优化的技术架构形式，旨在为<strong>服务、服务组合和服务库存</strong>提供最佳支持。</li>
</ol>
<h2 id="03-Service-Oriented-Architecture"><a href="#03-Service-Oriented-Architecture" class="headerlink" title="03 Service-Oriented Architecture"></a>03 Service-Oriented Architecture</h2><h3 id="一、-SOA核心概念"><a href="#一、-SOA核心概念" class="headerlink" title="一、 SOA核心概念"></a>一、 SOA核心概念</h3><p>SOA是从架构视角支持服务计算整体范式的<strong>基础架构模型</strong>。</p>
<ul>
<li><strong>本质</strong>：一种<strong>业务与IT对齐</strong>的方法，应用依赖于可用的服务来支撑业务流程。</li>
<li><strong>核心元素</strong>：服务。服务是<strong>自包含、可重用</strong>的软件组件，由<strong>服务提供者</strong>提供，被<strong>服务请求者</strong>消费。</li>
<li><strong>三角操作模型</strong>：是SOA的核心交互模式，包含：<ul>
<li><strong>服务提供者</strong>：发布服务接口。</li>
<li><strong>服务注册中心</strong>：提供服务查询接口。</li>
<li><strong>服务消费者</strong>：查找并绑定服务。</li>
</ul>
</li>
</ul>
<h3 id="二、-SOA的优势"><a href="#二、-SOA的优势" class="headerlink" title="二、 SOA的优势"></a>二、 SOA的优势</h3><ul>
<li><strong>IT视角</strong>：<ul>
<li><strong>松耦合与复用</strong>：通过标准接口消除对特定语言、平台、厂商、时间、访问地址和协议的依赖。</li>
<li><strong>灵活</strong>：支持服务的间接寻址和动态绑定。</li>
</ul>
</li>
<li><strong>业务视角</strong>：<ul>
<li><strong>保护投资</strong>：提升现有IT资源利用率，促进复用。</li>
<li><strong>提高敏捷性</strong>：快速响应业务变化。</li>
<li><strong>支持外包</strong>：便于整合外部服务。</li>
</ul>
</li>
</ul>
<h3 id="三、-SOA的多层次视图"><a href="#三、-SOA的多层次视图" class="headerlink" title="三、 SOA的多层次视图"></a>三、 SOA的多层次视图</h3><p>SOA在四个层次上提供指导，架起业务与IT的桥梁：</p>
<ol>
<li><strong>编程层</strong>：指导底层IT技术（如SOAP协议、服务组件架构SCA）。</li>
<li><strong>中间件层</strong>：指导通用产品&#x2F;开源软件的设计开发（如选择单&#x2F;多ESB，消息或事件驱动的基础设施）。</li>
<li><strong>流程层</strong>：指导业务流程集成、管理和事件驱动架构设计。</li>
<li><strong>企业层</strong>：指导企业组件化和高层转型咨询，帮助企业决策如何用SOA服务包实现流程。</li>
</ol>
<h3 id="四、-企业服务总线（ESB）"><a href="#四、-企业服务总线（ESB）" class="headerlink" title="四、 企业服务总线（ESB）"></a>四、 企业服务总线（ESB）</h3><p>ESB是实现SOA的关键基础设施。</p>
<ul>
<li><strong>概念</strong>：一种软件基础设施，<strong>促进服务组件的动态集成、消息路由、中介和控制</strong>。</li>
<li><strong>类比</strong>：类似于CORBA的“对象总线”或J2EE的“应用服务器”，但ESB集成的是服务。</li>
<li><strong>核心功能</strong>：集成、消息路由、协议&#x2F;数据转换、服务管理。</li>
<li><strong>高级功能</strong>：服务发现与供应、基于性能动态调整SLA、高级Web服务发现、特定技术适配器。</li>
</ul>
<h3 id="五、-SOA参考架构（SOA-RA）"><a href="#五、-SOA参考架构（SOA-RA）" class="headerlink" title="五、 SOA参考架构（SOA-RA）"></a>五、 SOA参考架构（SOA-RA）</h3><p>SOA-RA是一个分层架构模板，用于指导SOA解决方案的整体设计。</p>
<h4 id="1-水平层（功能层）"><a href="#1-水平层（功能层）" class="headerlink" title="1. 水平层（功能层）"></a>1. 水平层（功能层）</h4><p>分为服务提供者层（后端）和服务消费者层（前端）。</p>
<ul>
<li><strong>操作系统层</strong>：包含现有的打包应用、定制应用和遗留系统。</li>
<li><strong>服务组件层</strong>：<strong>实现服务接口的代码容器</strong>。它依赖下层操作系统的功能，并向上暴露为服务。负责输入转换和输出适配。</li>
<li><strong>服务层</strong>：<strong>服务的逻辑管理层</strong>。负责服务注册、发现、绑定、接口聚合和生命周期管理。包含<strong>服务集群</strong>的概念。</li>
<li><strong>业务流程层</strong>：<strong>处理服务组合与分解的所有业务逻辑</strong>。通过组合服务来协调业务流程以满足客户需求。组合方式主要有<strong>编排</strong>（集中控制）和<strong>编舞</strong>（分布式协调）。</li>
<li><strong>消费者层</strong>：<strong>负责表示层</strong>，快速构建用户界面以使用下层服务，支持多种用户&#x2F;渠道和缓存。</li>
</ul>
<h4 id="2-垂直层（支撑层）"><a href="#2-垂直层（支撑层）" class="headerlink" title="2. 垂直层（支撑层）"></a>2. 垂直层（支撑层）</h4><ul>
<li><strong>集成层</strong>：<strong>SOA解决方案的关键使能层</strong>，提供中介、路由和转换服务请求的能力。ESB是其典型代表。</li>
<li><strong>服务质量层</strong>：提供<strong>解决方案级</strong>的QoS管理（如可用性、可靠性、安全性），提供监控管理机制。</li>
<li><strong>数据架构层</strong>：提供统一的数据表示和集成框架（如电信业的SID模型）。</li>
<li><strong>治理层</strong>：提供设计指导，确保SOA解决方案架构的合理设计，建立最佳实践和原则。</li>
</ul>
<h3 id="六、-SOA实践与生命周期"><a href="#六、-SOA实践与生命周期" class="headerlink" title="六、 SOA实践与生命周期"></a>六、 SOA实践与生命周期</h3><ul>
<li><strong>服务导向建模与架构</strong>：一种应用SOA-RA的实践方法，包括三个步骤：<strong>服务识别、服务规约、服务实现</strong>。</li>
<li><strong>服务生命周期</strong>：从服务构思到不再使用的全过程。<ul>
<li><strong>建模</strong>：使用概念建模技术（如WSDL自顶向下分解、UML MDA）设计服务。</li>
<li><strong>开发</strong>：使用任何编程语言实现服务，涵盖设计、编码、测试。</li>
<li><strong>部署</strong>：<ul>
<li><strong>发布与发现</strong>：通过发布&#x2F;订阅模型实现。</li>
<li><strong>调用</strong>：消费者与提供者协商SLA后，通过SOAP等协议远程调用。</li>
<li><strong>组合</strong>：使用BPEL等将一组可用服务组合成业务流程。</li>
</ul>
</li>
<li><strong>协作</strong>：在复杂流程中协调多个不同提供者的服务，涉及信息交换与协作。</li>
<li><strong>监控与管理</strong>：监控Web服务执行，进行访问控制、性能监控、SLA执行和异常处理，在分布式多参与方环境中进行数据分析以持续改进。</li>
</ul>
</li>
</ul>
<h2 id="04-Message-exchange-and-Data-type"><a href="#04-Message-exchange-and-Data-type" class="headerlink" title="04 Message exchange and Data type"></a>04 Message exchange and Data type</h2><p>本章主要讲解服务计算中实现数据交换与处理的<strong>基础技术栈</strong>，核心是<strong>XML及其相关标准</strong>。这些技术是服务之间进行结构化、标准化通信的基石。</p>
<h3 id="一、-电子信息交换（Electronic-Information-Exchange）"><a href="#一、-电子信息交换（Electronic-Information-Exchange）" class="headerlink" title="一、 电子信息交换（Electronic Information Exchange）"></a>一、 电子信息交换（Electronic Information Exchange）</h3><p>电子信息交换是指在不同软件单元之间，为执行业务功能而进行的电子编码信息移动。</p>
<ul>
<li><strong>交换场景</strong>：<ul>
<li>应用内：同一应用不同部分之间。</li>
<li>应用间：同一公司系统内的不同应用之间。</li>
<li>系统间：同一公司内的不同系统之间。</li>
<li>公司间：不同公司之间。</li>
</ul>
</li>
<li><strong>核心挑战</strong>：在异构环境中，如何确保信息能被所有参与方<strong>无歧义地理解</strong>和<strong>正确处理</strong>。这需要<strong>标准化的数据格式</strong>和<strong>协议</strong>。</li>
</ul>
<h3 id="二、-XML-eXtensible-Markup-Language"><a href="#二、-XML-eXtensible-Markup-Language" class="headerlink" title="二、 XML (eXtensible Markup Language)"></a>二、 XML (eXtensible Markup Language)</h3><p>XML 是服务计算中的<strong>元语言</strong>，用于描述和交换结构化数据。</p>
<h4 id="1-核心特性"><a href="#1-核心特性" class="headerlink" title="1. 核心特性"></a>1. 核心特性</h4><ul>
<li><strong>纯文本</strong>：独立于平台和语言。</li>
<li><strong>自描述性</strong>：通过标签和属性描述数据结构。</li>
<li><strong>可扩展性</strong>：允许用户自定义标签。</li>
</ul>
<h4 id="2-格式良好（Well-formed）XML"><a href="#2-格式良好（Well-formed）XML" class="headerlink" title="2. 格式良好（Well-formed）XML"></a>2. 格式良好（Well-formed）XML</h4><p>必须遵循以下规则：</p>
<ul>
<li><strong>单一根元素</strong>：文档有且仅有一个根元素。</li>
<li><strong>标签规则</strong>：起始标签<code>&lt;tag&gt;</code>必须有对应的结束标签<code>&lt;/tag&gt;</code>；空元素可用<code>&lt;tag/&gt;</code>。</li>
<li><strong>正确嵌套</strong>：元素必须正确嵌套，内层元素必须在外层元素结束前结束。</li>
<li><strong>命名规则</strong>：名称以字母、下划线或冒号开头，区分大小写，不能包含空格，不能以“xml”开头。</li>
<li><strong>属性规则</strong>：属性值必须用引号括起（单双引号均可），同一元素内属性名必须唯一。</li>
<li><strong>XML声明</strong>：可选，通常位于文档首行，如 <code>&lt;?xml version=“1.0” encoding=“UTF-8”?&gt;</code>。</li>
<li><strong>注释与处理指令</strong>：注释为<code>&lt;!-- --&gt;</code>；处理指令为<code>&lt;?target ...?&gt;</code>。</li>
</ul>
<h4 id="3-字符数据处理"><a href="#3-字符数据处理" class="headerlink" title="3. 字符数据处理"></a>3. 字符数据处理</h4><ul>
<li><strong>PCDATA</strong>：解析字符数据，XML解析器会解析其中的实体引用（如 <code>&amp;lt;</code> 代表 <code>&lt;</code>）。</li>
<li><strong>CDATA</strong>：不解析的字符数据，用于包含可能被误解析为XML的文本块，格式为 <code>&lt;![CDATA[ ... ]]&gt;</code>。</li>
</ul>
<h4 id="4-格式良好-vs-有效（Valid）"><a href="#4-格式良好-vs-有效（Valid）" class="headerlink" title="4. 格式良好 vs. 有效（Valid）"></a>4. 格式良好 vs. 有效（Valid）</h4><ul>
<li><strong>格式良好</strong>：符合基本语法规则，所有XML解析器都会检查。</li>
<li><strong>有效</strong>：不仅格式良好，还<strong>符合特定模式定义</strong>（如DTD或XML Schema），需要<strong>验证解析器</strong>检查。</li>
</ul>
<h3 id="三、-命名空间（NameSpace）"><a href="#三、-命名空间（NameSpace）" class="headerlink" title="三、 命名空间（NameSpace）"></a>三、 命名空间（NameSpace）</h3><p>用于解决XML文档中<strong>元素和属性名冲突</strong>的问题，特别是合并来自不同来源的XML时。</p>
<h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>为每个名称（元素&#x2F;属性）附加一个<strong>全局唯一的URI</strong>作为限定符，从而形成两段式名称。</p>
<ul>
<li><strong>前缀映射</strong>：使用 <code>xmlns:prefix=“URI”</code> 声明命名空间，将前缀（如 <code>books</code>）映射到URI（如 <code>http://example.com/books</code>）。</li>
<li><strong>限定名</strong>：使用 <code>prefix:localName</code>（如 <code>books:title</code>）来表示一个完整、无歧义的名称。</li>
</ul>
<h4 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2. 关键概念"></a>2. 关键概念</h4><ul>
<li><strong>默认命名空间</strong>：使用 <code>xmlns=“URI”</code> 声明，作用于该元素及其所有未加前缀的子元素，<strong>但不作用于属性</strong>。</li>
<li><strong>作用域</strong>：命名空间声明在其所在元素及其所有后代元素中有效，除非被覆盖。</li>
<li><strong>重置</strong>：使用 <code>xmlns=“”</code> 可以清除默认命名空间。</li>
</ul>
<h3 id="四、-XML模式（XML-Schema）"><a href="#四、-XML模式（XML-Schema）" class="headerlink" title="四、 XML模式（XML Schema）"></a>四、 XML模式（XML Schema）</h3><p>用于<strong>定义XML文档的结构和数据类型</strong>，是服务合约中数据定义的核心技术。</p>
<h4 id="1-作用与特点"><a href="#1-作用与特点" class="headerlink" title="1. 作用与特点"></a>1. 作用与特点</h4><ul>
<li><strong>数据验证</strong>：比DTD更强大，支持丰富的数据类型和约束。</li>
<li><strong>命名空间支持</strong>：与命名空间紧密集成。</li>
<li><strong>自身也是XML</strong>：使用XML语法编写，便于工具处理。</li>
</ul>
<h4 id="2-核心元素"><a href="#2-核心元素" class="headerlink" title="2. 核心元素"></a>2. 核心元素</h4><ul>
<li><strong>元素声明</strong> (<code>&lt;xs:element&gt;</code>)<ul>
<li><code>type</code>：指定数据类型。</li>
<li><code>minOccurs</code>&#x2F;<code>maxOccurs</code>：指定出现次数（默认1，<code>unbounded</code>表示无限）。</li>
</ul>
</li>
<li><strong>简单类型 vs. 复杂类型</strong><ul>
<li><strong>简单类型</strong> (<code>&lt;xs:simpleType&gt;</code>)：不能包含子元素或属性，如字符串、整数。可通过<code>restriction</code>添加约束面（facet），如<code>length</code>、<code>pattern</code>、<code>enumeration</code>。</li>
<li><strong>复杂类型</strong> (<code>&lt;xs:complexType&gt;</code>)：可包含子元素和&#x2F;或属性。</li>
</ul>
</li>
<li><strong>组合器</strong><ul>
<li><code>sequence</code>：元素必须按指定顺序出现。</li>
<li><code>choice</code>：元素中只能出现一个。</li>
<li><code>all</code>：元素必须全部出现，但顺序不限。</li>
</ul>
</li>
<li><strong>属性声明</strong> (<code>&lt;xs:attribute&gt;</code>)</li>
<li><strong>全局与局部</strong>：全局定义（顶级元素）可被重用；局部定义（嵌套）仅用于特定位置。</li>
</ul>
<h4 id="3-模式定位"><a href="#3-模式定位" class="headerlink" title="3. 模式定位"></a>3. 模式定位</h4><p>在实例文档中，通过 <code>xsi:schemaLocation</code> 属性关联模式和命名空间。</p>
<h3 id="五、-XPath"><a href="#五、-XPath" class="headerlink" title="五、 XPath"></a>五、 XPath</h3><p>一种用于在XML文档中<strong>导航和查询节点</strong>的语言，是XSLT和XQuery的基础。</p>
<h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h4><ul>
<li><strong>节点</strong>：XML文档中的元素、属性、文本等都被视为节点。</li>
<li><strong>轴</strong>：定义了相对于当前节点的搜索方向（如 <code>child::</code>, <code>parent::</code>, <code>attribute::</code>, <code>descendant::</code>）。</li>
<li><strong>节点测试</strong>：指定要选择的节点类型（如 <code>node()</code>, <code>text()</code>, <code>@attName</code>）。</li>
<li><strong>谓词</strong>：在方括号 <code>[]</code> 内，用于过滤节点集（如 <code>[position()=1]</code>, <code>[@type=‘VIP’]</code>）。</li>
</ul>
<h4 id="2-路径表达式"><a href="#2-路径表达式" class="headerlink" title="2. 路径表达式"></a>2. 路径表达式</h4><ul>
<li><strong>绝对路径</strong>：以 <code>/</code> 开头，从根节点开始。</li>
<li><strong>相对路径</strong>：从当前节点开始。</li>
<li><strong>缩写语法</strong>：<code>//</code> 表示文档中任意位置的节点；<code>.</code> 表示当前节点；<code>..</code> 表示父节点。</li>
</ul>
<h3 id="六、-扩展样式表语言家族（XSL）"><a href="#六、-扩展样式表语言家族（XSL）" class="headerlink" title="六、 扩展样式表语言家族（XSL）"></a>六、 扩展样式表语言家族（XSL）</h3><p>用于XML文档的转换和格式化。</p>
<h4 id="1-XSLT-XSL-Transformations"><a href="#1-XSLT-XSL-Transformations" class="headerlink" title="1. XSLT (XSL Transformations)"></a>1. XSLT (XSL Transformations)</h4><p>用于将XML文档<strong>转换为其他XML文档、HTML或纯文本</strong>。</p>
<ul>
<li><strong>声明式、无副作用</strong>：基于模板规则，不依赖执行顺序。</li>
<li><strong>核心处理流程</strong>：<ol>
<li>读取源XML文档，构建源树。</li>
<li>应用样式表中的模板规则，生成结果树。</li>
<li>序列化结果树，输出最终文档。</li>
</ol>
</li>
<li><strong>关键元素</strong>：<ul>
<li><code>&lt;xsl:template match=“XPath”&gt;</code>：定义模板规则。</li>
<li><code>&lt;xsl:apply-templates&gt;</code>：指示处理器处理当前节点的子节点。</li>
<li><code>&lt;xsl:value-of select=“XPath”&gt;</code>：提取并输出节点值。</li>
<li><code>&lt;xsl:for-each&gt;</code>：循环处理节点集。</li>
<li><code>&lt;xsl:if&gt;</code>, <code>&lt;xsl:choose&gt;</code>：条件处理。</li>
<li><code>&lt;xsl:sort&gt;</code>：排序。</li>
<li><code>&lt;xsl:element&gt;</code>, <code>&lt;xsl:attribute&gt;</code>：动态生成元素和属性。</li>
</ul>
</li>
</ul>
<h4 id="2-XPath"><a href="#2-XPath" class="headerlink" title="2. XPath"></a>2. XPath</h4><p>如前所述，XSLT重度依赖XPath进行节点定位和匹配。</p>
<h3 id="七、-XML解析器"><a href="#七、-XML解析器" class="headerlink" title="七、 XML解析器"></a>七、 XML解析器</h3><p>用于读取、处理XML文档的程序组件。</p>
<h4 id="1-DOM-Document-Object-Model-解析器"><a href="#1-DOM-Document-Object-Model-解析器" class="headerlink" title="1. DOM (Document Object Model) 解析器"></a>1. DOM (Document Object Model) 解析器</h4><ul>
<li><strong>工作原理</strong>：<strong>一次性将整个XML文档加载到内存</strong>，构建成一个<strong>树形结构</strong>（节点树）。</li>
<li><strong>特点</strong>：<ul>
<li><strong>优点</strong>：可以随机访问和修改文档的任何部分。</li>
<li><strong>缺点</strong>：内存消耗大，不适合处理超大XML文件。</li>
</ul>
</li>
<li><strong>应用场景</strong>：需要对文档进行<strong>频繁、复杂操作</strong>（如增删改查）的场合。</li>
</ul>
<h4 id="2-SAX-Simple-API-for-XML-解析器"><a href="#2-SAX-Simple-API-for-XML-解析器" class="headerlink" title="2. SAX (Simple API for XML) 解析器"></a>2. SAX (Simple API for XML) 解析器</h4><ul>
<li><strong>工作原理</strong>：基于<strong>事件驱动</strong>。解析器顺序读取文档，遇到开始标签、结束标签、文本等“事件”时，触发回调函数。</li>
<li><strong>特点</strong>：<ul>
<li><strong>优点</strong>：内存占用极小（不构建整个树），解析速度快。</li>
<li><strong>缺点</strong>：只能顺序访问，无法随机修改；编程模型相对复杂，需要应用程序自己维护状态。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<strong>只需读取（特别是大型文档）、内容过滤或简单转换</strong>的场合，对性能要求高。</li>
</ul>
<h3 id="八、-数据表示标准化与服务合约"><a href="#八、-数据表示标准化与服务合约" class="headerlink" title="八、 数据表示标准化与服务合约"></a>八、 数据表示标准化与服务合约</h3><p>在服务计算中，上述技术的根本目的是实现<strong>数据表示标准化</strong>，这是服务合约长期稳定和可复用的前提。</p>
<ul>
<li><strong>核心挑战</strong>：如何定义“学生”信息？教务、医院、公安局各有不同需求，导致数据冗余或定义权冲突。</li>
<li><strong>面向服务视角的解决方案</strong>：<strong>优先使用官方发布的、标准化的模式定义</strong>，而不是为每个服务最小化定制数据结构。这确保了跨服务、跨组织交互时语义的一致性，尽管可能带来一定冗余，但换取了互操作性和长期演化的稳定性。<strong>服务合约（如WSDL）依赖于这些标准的XML Schema定义来描述其交换的数据类型</strong>。</li>
</ul>
<h2 id="05-Services-modeling"><a href="#05-Services-modeling" class="headerlink" title="05 Services modeling"></a>05 Services modeling</h2><h3 id="05-1-课程定位与演进"><a href="#05-1-课程定位与演进" class="headerlink" title="05.1 课程定位与演进"></a>05.1 课程定位与演进</h3><ul>
<li><strong>SOA (面向服务的架构)</strong>：一个概念层面的架构模型。</li>
<li><strong>Web Service</strong>: 是实现 SOA 模型的一种具体技术。</li>
<li><strong>技术演进脉络</strong>:<ol>
<li><strong>基础定义</strong>: 使用 XML、Namespace、XML Schema 定义了消息格式和数据结构。</li>
<li><strong>消息传输</strong>: 引入 SOAP，作为一种标准的传输协议，使不同平台和语言的应用程序能够通信。</li>
<li><strong>服务描述</strong>: 引入 WSDL (Web Services Description Language)，一种基于 XML 的标准接口定义语言，用于交换 Web Service 的调用信息（地点、方式、能力）。</li>
<li><strong>高级建模</strong>: 对于更复杂的服务（如复合服务、带有非功能需求的服务），可能需要额外的规范（如 WS-BPEL, WS-CDL, WS-*）来补充。</li>
</ol>
</li>
</ul>
<h3 id="05-2-SOAP-Basis"><a href="#05-2-SOAP-Basis" class="headerlink" title="05.2 SOAP Basis"></a>05.2 SOAP Basis</h3><ol>
<li>SOAP 简介与历史</li>
</ol>
<ul>
<li><strong>定义</strong>: SOAP 是一个基于 XML 的、用于在分布式环境中交换结构化信息的消息框架。它独立于编程模型和底层协议。</li>
<li><strong>不再是缩写</strong>: SOAP 1.2 中，<code>SOAP</code> 不再代表 <code>Simple Object Access Protocol</code>。</li>
<li><strong>历史</strong>:<ul>
<li><strong>XML-RPC (1998)</strong>: 先驱。</li>
<li><strong>SOAP 1.1 (2000)</strong>: 成为事实标准。</li>
<li><strong>SOAP 1.2 (2003&#x2F;2007)</strong>: W3C 推荐标准。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>SOAP 消息结构</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">env:Envelope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env:Header</span>&gt;</span> <span class="comment">&lt;!-- 可选，扩展机制，传递控制信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Header Blocks (头块) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">env:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env:Body</span>&gt;</span>   <span class="comment">&lt;!-- 必需，承载主要的端到端信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 消息体内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">env:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">env:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SOAP 处理模型</li>
</ol>
<ul>
<li><strong>SOAP 节点</strong>: 发送、接收、转发或处理 SOAP 消息的实体。</li>
<li><strong>SOAP 中介</strong>: 位于初始发送者和最终接收者路径上的节点，可以处理（检查、插入、删除、转发）消息头，提供增值服务。</li>
<li><strong>SOAP 不规定</strong>: 头块的具体内容、消息的路由方式等。</li>
</ul>
<ol start="4">
<li>两种交互模式</li>
</ol>
<ul>
<li><strong>文档导向模式</strong>: 异步交互，发送完整的 XML 文档。</li>
<li><strong>远程过程调用模式</strong>: 同步请求&#x2F;响应交互，模拟程序调用。</li>
</ul>
<ol start="5">
<li>SOAP 故障模型</li>
</ol>
<ul>
<li><strong><code>env:Fault</code> 元素</strong>: 所有 SOAP 和应用级故障都必须通过此元素在 Body 中报告。</li>
<li><strong>结构</strong>:<ul>
<li><strong>必需</strong>: <code>env:Code</code> (故障代码), <code>env:Reason</code> (人类可读原因)。</li>
<li><strong>可选</strong>: <code>env:Detail</code> (应用特定信息), <code>env:Node</code> (故障节点URI), <code>env:Role</code> (故障节点角色)。</li>
</ul>
</li>
<li><strong><code>Misunderstood</code> 头</strong>: 当无法处理强制(<code>mustUnderstand=&quot;true&quot;</code>)头块时，在返回的 Fault 消息的 Header 中使用此元素标识未被理解的头块。</li>
</ul>
<ol start="6">
<li>RPC 与 SOAP</li>
</ol>
<ul>
<li><strong>RPC 调用要素</strong>: 目标节点地址、方法名、参数（输入&#x2F;输出&#x2F;返回值）、消息交换模式、可选的头块数据。</li>
<li><strong>RPC 与底层协议</strong>: RPC 抽象独立于传输机制。通常依赖绑定（如 HTTP 绑定）或自定义相关 ID 来实现请求-响应的关联。</li>
</ul>
<h3 id="05-3-SOAP-Extension"><a href="#05-3-SOAP-Extension" class="headerlink" title="05.3 SOAP Extension"></a>05.3 SOAP Extension</h3><ol>
<li>SOAP 处理模型与 <code>role</code> 属性</li>
</ol>
<ul>
<li><strong><code>env:role</code></strong>: 存在于头块中的可选属性 (<code>xs:anyURI</code>)，标识该头块的<strong>预期目标</strong>所扮演的“角色”。</li>
<li><strong>标准化角色</strong>:<ul>
<li><code>next</code>: 每个接收消息的 SOAP 节点都必须能够处理标为此角色的头块。</li>
<li><code>ultimateReceiver</code>: 消息的最终接收者角色。<strong>Body 元素总是以此角色为目标</strong>。</li>
<li><code>none</code>: 没有 SOAP 节点应处理此头块内容。</li>
</ul>
</li>
<li><strong>默认角色</strong>: 如果头块没有 <code>env:role</code> 属性，则其目标角色默认为 <code>ultimateReceiver</code>。</li>
</ul>
<ol start="2">
<li><code>mustUnderstand</code> 属性</li>
</ol>
<ul>
<li><strong>作用</strong>: 如果设置为 <code>&quot;true&quot;</code>，则目标 SOAP 节点<strong>必须</strong>按照该头块的规范处理它，否则必须生成一个 SOAP 故障。此类头块称为<strong>强制头块</strong>。</li>
<li><strong>Body</strong>: <code>env:Body</code> 元素没有此属性，但必须被最终接收者处理。</li>
</ul>
<ol start="3">
<li><code>relay</code> 属性</li>
</ol>
<ul>
<li><strong>问题</strong>: 默认情况下，未被 SOAP 中介处理的目标头块（<code>role</code> 非 <code>ultimateReceiver</code>）在转发前会被移除。</li>
<li><strong>解决方案</strong>: <code>env:relay=&quot;true&quot;</code> 指示，即使一个目标为中介但未被该中介处理的头块，也应被<strong>转发</strong>给下游节点。</li>
<li><strong>使用场景</strong>: 与 <code>mustUnderstand=&quot;false&quot;</code> 结合，用于在消息路径上引入新的可选功能。</li>
</ul>
<ol start="4">
<li>SOAP 中介</li>
</ol>
<ul>
<li><strong>转发中介</strong>: 基于接收到的 SOAP 消息中的头块语义或使用的 MEP，将消息转发到另一个 SOAP 节点（例如，路由头块）。</li>
<li><strong>主动中介</strong>: 在转发前对消息进行额外处理（例如，加密部分消息、添加时间戳头块、插入新头块描述修改）。</li>
</ul>
<ol start="5">
<li>二进制数据传输优化</li>
</ol>
<ul>
<li><strong>传统方式 (Base64)</strong>:<ul>
<li>将二进制数据编码为 <code>xs:base64Binary</code> 类型的字符。</li>
<li><strong>缺点</strong>: 消息体积显著增加（约33%），编解码有处理开销。</li>
</ul>
</li>
<li><strong>MTOM (消息传输优化机制)</strong>:<ul>
<li><strong>核心思想</strong>: 避免对大块二进制内容进行 Base64 编码。</li>
<li><strong>实现</strong>: 基于 XOP (XML-binary Optimized Packaging)，使用 MIME <code>Multipart/Related</code> 包。<ul>
<li>根部分包含修改后的 SOAP 信封（使用 <code>xop:Include</code> 元素作为二进制数据的占位符）。</li>
<li>相关部分包含实际的二进制数据。</li>
<li>通过 <code>href</code> 属性（如 <code>cid:...</code>）进行链接。</li>
</ul>
</li>
<li><strong>要求</strong>: 原始的 Base64 编码必须是<strong>规范形式</strong>，以确保二进制值与字符表示之间的一一对应。</li>
</ul>
</li>
<li><strong>URI 引用优化</strong>: 在 SOAP 消息中通过 URI 引用外部资源（如图片）。适用于同一资源被多次引用的场景。</li>
<li><strong>资源表示头块</strong>: 当不希望或无法通过 URI 解引用获取资源时，可以使用 <code>rep:Representation</code> 头块将资源的 Base64 表示或优化后的二进制表示直接携带在消息中。</li>
</ul>
<h3 id="05-4-SOAP-Binding"><a href="#05-4-SOAP-Binding" class="headerlink" title="05.4 SOAP Binding"></a>05.4 SOAP Binding</h3><ol>
<li>SOAP 绑定的任务</li>
</ol>
<ul>
<li><strong>定义</strong>: 描述如何使用某种底层协议（如 HTTP、SMTP）在 SOAP 节点间传递 SOAP 消息。</li>
<li><strong>核心任务</strong>:<ol>
<li>提供 SOAP 信息集的序列化表示，以便传输，并能无损重建。</li>
<li>可支持附加功能，如压缩、加密。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>特性与模块</li>
</ol>
<ul>
<li><strong>特性</strong>: 两个 SOAP 节点间交互所需功能的规范（如加密通道、可靠传递）。由 URI 标识。</li>
<li><strong>实现方式</strong>:<ol>
<li><strong>绑定原生支持</strong>：底层协议直接提供（如 HTTP 的请求&#x2F;响应关联）。</li>
<li><strong>SOAP 模块</strong>：在 SOAP 信封内通过头块实现。</li>
<li><strong>应用直接实现</strong>。</li>
</ol>
</li>
</ul>
<ol start="3">
<li>消息交换模式</li>
</ol>
<ul>
<li><strong>SOAP 请求-响应 MEP</strong>: 两个相邻节点间双向交换一条消息。</li>
<li><strong>SOAP 响应 MEP</strong>: 一个非 SOAP 消息（如 HTTP GET 请求）后跟一个作为响应一部分的 SOAP 消息。</li>
</ul>
<ol start="4">
<li>SOAP HTTP 绑定（重点）</li>
</ol>
<ul>
<li><strong>使用 SOAP Web 方法特性</strong>，限制为 GET 或 POST。</li>
<li><strong>两种模式</strong>:<ol>
<li><strong>SOAP 请求-响应 MEP</strong> (<code>POST</code>): 主要用于创建或修改资源状态。SOAP 消息放在 HTTP 请求和响应的 Body 中。</li>
<li><strong>SOAP 响应 MEP</strong> (<code>GET</code>): 主要用于安全、幂等地获取资源表示。HTTP GET 请求返回一个 SOAP 消息。<strong>无法在请求中携带 SOAP 头块</strong>。</li>
</ol>
</li>
<li><strong>Web 架构兼容的使用建议</strong>:<ul>
<li><strong>安全信息检索</strong>: 应使用 <code>GET</code> 和 <strong>SOAP 响应 MEP</strong>。资源标识应体现在 HTTP 请求 URI 中。</li>
<li><strong>非安全操作或需要头块</strong>: 使用 <code>POST</code> 和 <strong>SOAP 请求-响应 MEP</strong>。同样建议将资源标识部分放在请求 URI 中，参数可同时保留在 SOAP Body 中。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>编码方案</li>
</ol>
<ul>
<li><strong><code>env:encodingStyle</code> 属性</strong>: 用于限定头块、Body 子元素等的序列化&#x2F;编码方案（如 SOAP 编码、RDF 编码）。</li>
<li><strong>选择</strong>: 编码方案的选择是应用特定的，互操作性通过“带外”协商保证。</li>
</ul>
<ol start="6">
<li>SOAP Over Email (非规范)</li>
</ol>
<ul>
<li>可通过 SMTP&#x2F;Email 传输 SOAP 消息（作为邮件正文或附件）。</li>
<li>本质上是单向的，依赖于邮件基础设施的投递状态通知。请求和响应的关联需要在应用层实现。</li>
</ul>
<h3 id="05-5-WSDL-Basis"><a href="#05-5-WSDL-Basis" class="headerlink" title="05.5 WSDL Basis"></a>05.5 WSDL Basis</h3><ol>
<li>WSDL 基本概念与历史</li>
</ol>
<ul>
<li><strong>定义</strong>: 一种用于描述网络服务（端点、操作、消息、协议）的 XML 格式。常与 SOAP 和 XML Schema 结合使用。</li>
<li><strong>历史</strong>: WSDL 1.0 (2000, IBM&#x2F;MS&#x2F;Ariba) -&gt; WSDL 1.1 (2001, 事实标准) -&gt; WSDL 2.0 (2007, W3C 推荐标准)。<strong>主要学习 WSDL 2.0</strong>。</li>
</ul>
<ol start="2">
<li>WSDL 2.0 文档结构</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">description</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>/&gt;</span>?</span><br><span class="line">    [<span class="tag">&lt;<span class="name">import</span>/&gt;</span> | <span class="tag">&lt;<span class="name">include</span>/&gt;</span>]*</span><br><span class="line">    <span class="tag">&lt;<span class="name">types</span>/&gt;</span>?</span><br><span class="line">    [<span class="tag">&lt;<span class="name">interface</span>/&gt;</span> | <span class="tag">&lt;<span class="name">binding</span>/&gt;</span> | <span class="tag">&lt;<span class="name">service</span>/&gt;</span>]*</span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>核心组件定义</li>
</ol>
<ul>
<li><strong><code>types</code></strong>: 定义消息的数据类型（通常使用内联或导入的 XML Schema）。</li>
<li><strong><code>interface</code></strong>: 定义服务的抽象接口，包含一组<code>operation</code>（操作）。操作定义了消息类型和使用的消息交换模式。</li>
<li><strong><code>binding</code></strong>: 为特定<code>interface</code>提供具体的消息格式和传输协议细节（如 SOAP over HTTP）。</li>
<li><strong><code>service</code></strong>: 指定一个服务支持的<code>interface</code>，以及一个或多个访问该服务的<code>endpoint</code>（端点），每个端点引用一个具体的<code>binding</code>和网络地址。</li>
</ul>
<ol start="4">
<li>目标命名空间</li>
</ol>
<ul>
<li><strong>作用</strong>: 类似于 XML Schema 的目标命名空间，用于唯一标识和区分 WSDL 文档中定义的组件。</li>
<li><strong>要求</strong>: 应为绝对 URI，且最好可以解引用到描述该服务的权威 WSDL 文档。</li>
</ul>
<h3 id="05-6-WSDL-InfoSet-Component-Model"><a href="#05-6-WSDL-InfoSet-Component-Model" class="headerlink" title="05.6 WSDL InfoSet &amp; Component Model"></a>05.6 WSDL InfoSet &amp; Component Model</h3><ol>
<li>WSDL 2.0 信息集与组件模型</li>
</ol>
<ul>
<li><strong>信息集</strong>: WSDL 2.0 语言基于 XML 信息集定义，一个 WSDL 文档即一个符合规范的 <code>description</code> 元素信息项。</li>
<li><strong>组件模型</strong>: 为了精确定义语义约束和含义，WSDL 2.0 在信息集之上抽象出一层<strong>组件模型</strong>（如 Description, Interface, Binding, Service 等组件）。约束和含义都在组件模型层面定义。</li>
</ul>
<ol start="2">
<li>模块化：<code>import</code> 与 <code>include</code></li>
</ol>
<ul>
<li><strong><code>include</code></strong>: 用于<strong>组装同一 WSDL 命名空间</strong>的多个 WSDL 文档。效果是累积的。</li>
<li><strong><code>import</code></strong>: 用于声明对<strong>不同 WSDL 命名空间</strong>中组件的引用。必须使用此机制来引用其他命名空间。</li>
<li><strong><code>location</code> 属性</strong>: 对处理器查找导入&#x2F;包含文档位置的提示，非强制。</li>
</ul>
<ol start="3">
<li>定义消息类型 (<code>types</code>) 的最佳实践</li>
</ol>
<ul>
<li><strong>内联模式</strong>: 直接在 <code>types</code> 元素内使用 <code>xs:schema</code>。</li>
<li><strong>分离模式 (推荐)</strong>: 将模式定义在单独的 <code>.xsd</code> 文件中，在 <code>types</code> 内使用 <code>xs:import</code> 导入。便于跨多个 WSDL 文档复用。</li>
<li><strong>关键区别</strong>:<ul>
<li><code>xs:import</code> <strong>直接放在 <code>types</code> 下</strong>: 导入的模式对该 WSDL 文档<strong>可见</strong>。</li>
<li><code>xs:import</code> <strong>放在内联的 <code>xs:schema</code> 内</strong>: 导入的模式仅对该内联模式<strong>可见</strong>，对该 WSDL 文档不可见。</li>
<li><code>xs:include</code> <strong>放在内联的 <code>xs:schema</code> 内</strong>: 包含的模式成为内联模式的一部分，对该 WSDL 文档<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<h3 id="05-7-WSDL-Interface-Binding"><a href="#05-7-WSDL-Interface-Binding" class="headerlink" title="05.7 WSDL Interface &amp; Binding"></a>05.7 WSDL Interface &amp; Binding</h3><ol>
<li>接口 (<code>interface</code>)</li>
</ol>
<ul>
<li><strong>继承 (<code>extends</code>)</strong>: 允许接口继承一个或多个其他接口的操作和故障定义。</li>
<li><strong>故障 (<code>fault</code>)</strong>: 在接口级别定义故障类型，可在多个操作中重用。故障类似于特殊的消息。</li>
<li><strong>操作 (<code>operation</code>)</strong>:<ul>
<li><strong>必需属性</strong>: <code>name</code>, <code>pattern</code> (标识所使用的 MEP 的 URI)。</li>
<li><strong>可选属性</strong>: <code>style</code> (标识定义操作时遵循的规则集，如 RPC 风格、IRI 风格)。</li>
<li><strong>安全操作 (<code>wsdlx:safe</code>)</strong>: 标记为 <code>true</code> 表示该操作对客户端是安全的（如查询），便于基础设施进行优化（如缓存）。</li>
</ul>
</li>
<li><strong>消息引用</strong>: 包含 <code>input</code>, <code>output</code>, <code>infault</code>, <code>outfault</code> 元素，通过 <code>messageLabel</code> 与 MEP 中的消息占位符关联，通过 <code>element</code> 属性指定消息内容模式。</li>
</ul>
<ol start="2">
<li>消息交换模式</li>
</ol>
<ul>
<li><strong>MEP</strong>: 定义抽象消息的顺序和基数。WSDL 2.0 预定义了 8 种 MEP (如 In-Only, Robust In-Only, In-Out, Out-Only等)。</li>
<li><strong>抽象性</strong>: MEP 抽象了具体的消息类型、时序、同步&#x2F;异步、单&#x2F;多通道等细节，通过 URI 标识，具有可扩展性。</li>
</ul>
<ol start="3">
<li>绑定 (<code>binding</code>)</li>
</ol>
<ul>
<li><strong>作用</strong>: 提供协议和编码细节，指定<strong>如何</strong>发送&#x2F;接收消息。</li>
<li><strong>实现</strong>: 通过 WSDL 的开放内容模型，使用<strong>绑定扩展</strong>（如 SOAP 绑定扩展、HTTP 绑定扩展）来指定。</li>
<li><strong>可重用绑定</strong>: 省略 <code>interface</code> 属性，不指定操作级细节，仅通过默认规则。仅在从 <code>endpoint</code> 引用时才与特定接口关联。</li>
<li><strong>绑定操作&#x2F;故障</strong>: 通过 <code>ref</code> 属性引用接口中定义的抽象操作&#x2F;故障，并为其提供具体的绑定信息。</li>
</ul>
<ol start="4">
<li>SOAP 绑定扩展</li>
</ol>
<ul>
<li><strong>主要支持 SOAP 1.2</strong>，兼容 SOAP 1.1。</li>
<li>定义了默认规则，允许在接口级别指定绑定，操作级别可覆盖。</li>
<li><strong>必须为故障显式提供绑定信息</strong>。</li>
</ul>
<ol start="5">
<li>HTTP 绑定扩展</li>
</ol>
<ul>
<li>支持 HTTP 1.1 和 HTTPS 原生协议。</li>
<li><strong>序列化</strong>:<ul>
<li><strong>GET 默认输入序列化</strong>: <code>application/x-www-form-urlencoded</code>。</li>
<li>使用花括号 <code>{typeName}</code> 在 <code>whttp:location</code> 中指定如何将输入数据序列化到请求 URI 的路径部分。末尾是否加 <code>/</code> 决定剩余数据是放在查询字符串还是消息体中。</li>
</ul>
</li>
<li><strong>GET vs POST 选择</strong>:<ul>
<li><strong>设计原则</strong>: 对<strong>安全</strong>操作使用 <code>GET</code>，可能改变资源状态的操作使用 <code>POST</code>。</li>
<li><strong>与 <code>wsdlx:safe</code> 联动</strong>: 如果接口操作标记为安全(<code>wsdlx:safe=&quot;true&quot;</code>)，且 HTTP 绑定未显式指定方法，则<strong>默认使用 <code>GET</code></strong>。</li>
</ul>
</li>
</ul>
<h2 id="06-Web-Services-Publishing-and-Discovery"><a href="#06-Web-Services-Publishing-and-Discovery" class="headerlink" title="06 Web Services Publishing and Discovery"></a>06 Web Services Publishing and Discovery</h2><h3 id="1-Web服务发布概述"><a href="#1-Web服务发布概述" class="headerlink" title="1. Web服务发布概述"></a>1. Web服务发布概述</h3><ul>
<li><strong>发布目的</strong>：将部署在应用服务器上的Web服务，注册到互联网上的<strong>服务注册中心</strong>，以便被用户发现。</li>
<li><strong>注册中心提供的信息</strong>：服务名称、提供商名称、描述服务的WSDL文件URL等元数据，<strong>而非服务的具体实现</strong>。</li>
<li><strong>主要发布方式</strong>：<ol>
<li><strong>集中式注册</strong>：发布到中心化的服务注册中心，如<strong>UDDI</strong>。</li>
<li><strong>分布式注册</strong>：发布到分布式的服务注册表，如<strong>WSIL</strong>。</li>
</ol>
</li>
</ul>
<h3 id="2-UDDI-集中式注册"><a href="#2-UDDI-集中式注册" class="headerlink" title="2. UDDI (集中式注册)"></a>2. UDDI (集中式注册)</h3><ul>
<li><strong>定义</strong>：通用描述、发现与集成，为Web服务的发布和发现提供“元服务”，支持对丰富元数据的查询。</li>
<li><strong>存储信息</strong>：以XML消息格式存储注册的Web服务描述。</li>
<li><strong>信息分类（类比电话簿）</strong>：<ul>
<li><strong>白页</strong>：基础联系信息（名称、地址等）。</li>
<li><strong>黄页</strong>：基于分类法的业务&#x2F;服务信息（行业、产品&#x2F;服务、地理位置）。</li>
<li><strong>绿页</strong>：技术服务信息（如何调用服务的技术细节）。</li>
</ul>
</li>
</ul>
<h3 id="3-UDDI-核心数据结构（重点）"><a href="#3-UDDI-核心数据结构（重点）" class="headerlink" title="3. UDDI 核心数据结构（重点）"></a>3. UDDI 核心数据结构（重点）</h3><p>包含五个主要元素，用于分层描述服务信息：</p>
<ol>
<li><p><strong><code>businessEntity</code></strong>：描述<strong>服务提供商（企业）</strong> 的基本信息（名称、描述、联系方式）。</p>
<ul>
<li>包含 <code>identifierBag</code> (标识符集，如自定义的企业工商注册号) 和 <code>categoryBag</code> (分类信息集，按行业、产品、地域等分类)。</li>
</ul>
</li>
<li><p><strong><code>businessService</code></strong>：描述企业提供的<strong>具体服务</strong>。</p>
<ul>
<li>归属于一个 <code>businessEntity</code>，包含服务名称、描述以及指向技术绑定(<code>bindingTemplate</code>)的列表。</li>
</ul>
</li>
<li><p><strong><code>bindingTemplate</code></strong>：描述<strong>如何调用服务</strong>的技术细节。</p>
<ul>
<li>包含访问点(<code>accessPoint</code>，即服务端点URL)和指向<code>tModel</code>的引用(<code>tModelInstanceDetails</code>)。</li>
</ul>
</li>
<li><p><strong><code>tModel</code> (技术模型)</strong>：描述<strong>唯一的概念或结构</strong>，是UDDI中的核心可重用组件。</p>
<ul>
<li><strong>最常见用途</strong>：<strong>指向一个WSDL文档</strong>，用于描述服务接口或绑定。通过 <code>overviewURL</code> 属性链接到WSDL文件。</li>
<li>也用于定义分类法、标识符系统等。通过 <code>categoryBag</code> 中的 <code>keyedReference</code> (keyName&#x3D;<code>&quot;uddi-org:types&quot;</code>, keyValue&#x3D;<code>&quot;wsdlSpec&quot;</code>) 来标识这是一个WSDL规范。</li>
</ul>
</li>
<li><p><strong><code>publisherAssertion</code></strong>：用于声明<strong>业务实体之间的关系</strong>（如父子公司、合作伙伴）。</p>
</li>
</ol>
<h3 id="4-UDDI-发展"><a href="#4-UDDI-发展" class="headerlink" title="4. UDDI 发展"></a>4. UDDI 发展</h3><ul>
<li><strong>v3.0 (2005)</strong> 是当前主要版本，强调支持<strong>企业内部服务基础设施</strong>和联邦控制，而非高度分布式的公共注册。</li>
<li><strong>新特性</strong>：注册联盟、发布者分配的键、订阅API、数字签名支持、改进的信息模型和发现功能等。</li>
</ul>
<h3 id="5-UDDI-API"><a href="#5-UDDI-API" class="headerlink" title="5. UDDI API"></a>5. UDDI API</h3><ul>
<li><strong>传输层</strong>：使用SOAP。</li>
<li><strong>交互模式</strong>：请求&#x2F;响应。</li>
<li><strong>两类API</strong>：<ul>
<li><strong>查询API</strong>：用于搜索和读取注册中心数据（浏览模式 <code>find_*</code> 和下钻模式 <code>get_*Detail</code>）。</li>
<li><strong>发布API</strong>：用于添加、更新和删除注册中心数据（涉及授权、保存、获取、删除操作）。</li>
</ul>
</li>
</ul>
<h3 id="6-WSIL-分布式发现"><a href="#6-WSIL-分布式发现" class="headerlink" title="6. WSIL (分布式发现)"></a>6. WSIL (分布式发现)</h3><ul>
<li><strong>核心思想</strong>：将Web服务作为普通的XML文档（<code>.wsil</code>文件）发布到常规Web服务器上，无需复杂的中心化注册设施。</li>
<li><strong>工作原理</strong>：WSIL文档通过 <code>description</code> 元素<strong>直接引用WSDL文件</strong>，或通过 <code>link</code> 元素<strong>链接到其他WSIL文档</strong>，从而形成<strong>WSIL链</strong>。</li>
<li><strong>优势</strong>：成本低，复杂度低，易于部署。</li>
<li><strong>劣势</strong>：发现依赖于链的起始点和遍历，不如UDDI查询强大和系统化。</li>
</ul>
<h3 id="7-服务发现"><a href="#7-服务发现" class="headerlink" title="7. 服务发现"></a>7. 服务发现</h3><ul>
<li><strong>UDDI发现</strong>：<ul>
<li>使用UDDI客户端（如UDDI4J）通过查询API进行搜索。</li>
<li>搜索方向：按业务、服务、服务类型进行查找，可基于名称、标识符、分类等进行过滤。</li>
</ul>
</li>
<li><strong>WSIL发现</strong>：<ul>
<li>本质上是<strong>迭代遍历WSIL链</strong>的过程：<ol>
<li>定位起始WSIL文档。</li>
<li>解析文档，获取其中列出的服务描述(<code>description</code>)和链接(<code>link</code>)。</li>
<li>跟随感兴趣的链接，获取新的WSIL文档或WSDL。</li>
<li>重复步骤2-3，直到找到目标信息。</li>
</ol>
</li>
<li>通常通过WSIL解析工具（如WSIL4J）实现。</li>
</ul>
</li>
</ul>
<h3 id="8-JAXR-统一注册访问API"><a href="#8-JAXR-统一注册访问API" class="headerlink" title="8. JAXR (统一注册访问API)"></a>8. JAXR (统一注册访问API)</h3><ul>
<li><strong>定义</strong>：用于访问<strong>多种注册中心</strong>（如UDDI，ebXML）的<strong>标准Java API</strong>。</li>
<li><strong>作用</strong>：提供统一的<strong>信息模型</strong>和<strong>多层API抽象</strong>，使客户端能用同一套接口访问不同的底层注册中心。</li>
<li><strong>架构角色</strong>：<ul>
<li><strong>Registry Provider</strong>：实现特定注册规范（如UDDI服务器）。</li>
<li><strong>JAXR Provider</strong>：实现JAXR规范，作为访问Registry Provider的门面。</li>
<li><strong>JAXR Client</strong>：使用JAXR API访问JAXR Provider提供的服务。</li>
</ul>
</li>
</ul>
<h2 id="07-Extension-of-Web-Services"><a href="#07-Extension-of-Web-Services" class="headerlink" title="07 Extension of Web Services"></a>07 Extension of Web Services</h2><h3 id="1-WS-概述"><a href="#1-WS-概述" class="headerlink" title="1. WS-* 概述"></a>1. WS-* 概述</h3><ul>
<li><strong>定义</strong>：指除核心标准（XML, SOAP, WSDL）之外，用于扩展Web服务功能的一系列标准规范的总称。</li>
<li><strong>特点</strong>：标准众多，由不同的标准组织或公司制定，涵盖了Web服务交互的各个方面。</li>
</ul>
<h3 id="2-复合服务"><a href="#2-复合服务" class="headerlink" title="2. 复合服务"></a>2. 复合服务</h3><ul>
<li><strong>需求背景</strong>：<ul>
<li>为了复用和灵活性，垂直业务服务可以由多个水平基础服务组合而成。</li>
<li>由活动（服务实现）构成的商业流程，需要由<strong>复合服务</strong>来实现。</li>
</ul>
</li>
<li><strong>实现方式</strong>：<ul>
<li>传统方式：在编程环境中调用子服务，再将整个程序单元封装为服务。</li>
<li><strong>标准方式</strong>：使用基于XML的流程描述语言（如<strong>BPEL</strong>）来标准化地描述服务组合。</li>
</ul>
</li>
</ul>
<h3 id="3-BPEL-业务流程执行语言"><a href="#3-BPEL-业务流程执行语言" class="headerlink" title="3. BPEL (业务流程执行语言)"></a>3. BPEL (业务流程执行语言)</h3><ul>
<li><strong>目的</strong>：将多个Web服务协调编排成一个完整的业务流程，定义交互的<strong>状态和逻辑</strong>。</li>
<li><strong>关键能力</strong>：精确定义跨企业业务协议的行为，包括数据依赖行为、异常处理、长时间运行交互等。</li>
<li><strong>两种建模方式</strong>：<ul>
<li><strong>可执行流程</strong>：建模参与方在业务交互中的实际行为。</li>
<li><strong>抽象流程</strong>：仅指定参与方之间相互可见的消息交换行为，不暴露内部实现。</li>
</ul>
</li>
<li><strong>开发流程</strong>：采用<strong>两阶段法</strong>——先创建服务描述(WSDL)，再创建业务流程(BPEL)。</li>
</ul>
<h3 id="4-BPEL-核心概念与示例"><a href="#4-BPEL-核心概念与示例" class="headerlink" title="4. BPEL 核心概念与示例"></a>4. BPEL 核心概念与示例</h3><ul>
<li><strong><code>partnerLinkType</code> (在WSDL中定义)</strong>：定义两个Web服务之间的<strong>会话关系</strong>，关联到<code>portType</code>和角色。</li>
<li><strong><code>partnerLink</code> (在BPEL中定义)</strong>：建模业务流程与之交互的<strong>伙伴服务</strong>，由<code>partnerLinkType</code>定义其特征。</li>
<li><strong><code>variable</code> (变量)</strong>：用于维护流程的<strong>状态数据和历史</strong>，类型基于WSDL消息类型。</li>
<li><strong><code>activity</code> (活动)</strong>：<ul>
<li><strong>基本活动</strong>：如<code>receive</code>（接收请求）、<code>reply</code>（回复响应）、<code>invoke</code>（调用伙伴服务）。</li>
<li><strong>结构化活动</strong>：如<code>sequence</code>（顺序）、<code>flow</code>（并发）、<code>switch</code>（分支）、<code>while</code>（循环）、<code>pick</code>（非确定性选择）。</li>
</ul>
</li>
<li><strong>流程示例（采购订单）</strong>：<ol>
<li><code>receive</code>：接收客户的采购订单。</li>
<li><code>invoke</code>：依次或并行调用支付服务和物流服务。</li>
<li><code>reply</code>：向客户回复处理结果。</li>
</ol>
</li>
</ul>
<h3 id="5-消息分发与WS-Addressing"><a href="#5-消息分发与WS-Addressing" class="headerlink" title="5. 消息分发与WS-Addressing"></a>5. 消息分发与WS-Addressing</h3><ul>
<li><strong>问题</strong>：WSDL本身不足以让接收者<strong>唯一标识</strong>应处理消息的Web服务实例，尤其是在一个端点托管多个服务时。</li>
<li><strong>解决方案</strong>：<strong>WS-Addressing</strong>规范。</li>
<li><strong>核心机制</strong>：<ul>
<li>在SOAP头中定义<code>wsa:Action</code>属性，其值<strong>唯一标识消息类型</strong>，接收方可据此进行消息分发。</li>
<li>为每种消息类型定义了默认的<code>Action</code>值。</li>
</ul>
</li>
<li><strong>其他功能</strong>：<ul>
<li><strong>端点引用</strong>：描述一个Web服务端点，包含地址、端口类型、服务名及自定义引用属性。</li>
<li><strong>消息关联头块</strong>：如<code>MessageID</code>, <code>ReplyTo</code>, <code>To</code>, <code>From</code>, <code>FaultTo</code>, <code>RelatesTo</code>，用于在异步、多消息交换中关联请求与响应。</li>
</ul>
</li>
</ul>
<h3 id="6-有状态服务与WSRF"><a href="#6-有状态服务与WSRF" class="headerlink" title="6. 有状态服务与WSRF"></a>6. 有状态服务与WSRF</h3><ul>
<li><strong>无状态 vs. 有状态服务</strong>：<ul>
<li><strong>无状态</strong>：不维护上下文，轻量级，扩展性好，容错性高。</li>
<li><strong>有状态</strong>：维护持久化信息以提供个性化、更复杂的服务，但需要更多编码和资源。</li>
</ul>
</li>
<li><strong>有状态服务建模</strong>：<strong>WSRF (Web服务资源框架)</strong>。</li>
<li><strong>WSRF核心规范</strong>：<ul>
<li><strong>WS-ResourceProperties</strong>：定义和访问资源（状态）的属性。</li>
<li><strong>WS-ResourceLifetime</strong>：管理资源（状态）的生命周期（立即销毁或定时销毁）。</li>
<li><strong>WS-BaseFault</strong>：定义基础故障类型。</li>
<li><strong>WS-ServiceGroup</strong>：对资源进行分组管理。</li>
</ul>
</li>
<li><strong>关联方式</strong>：在WSDL的<code>portType</code>定义中，通过<code>wsrp:resourceProperties</code>属性关联到描述资源属性的XML Schema。</li>
</ul>
<h3 id="7-Web服务QoS-质量保障"><a href="#7-Web服务QoS-质量保障" class="headerlink" title="7. Web服务QoS (质量保障)"></a>7. Web服务QoS (质量保障)</h3><p>主要涵盖四个类别的标准：</p>
<ul>
<li><strong>安全</strong></li>
<li><strong>事务</strong></li>
<li><strong>可靠消息传递</strong></li>
<li><strong>资源生命周期管理</strong></li>
</ul>
<h3 id="8-安全-WS-Security"><a href="#8-安全-WS-Security" class="headerlink" title="8. 安全 (WS-Security)"></a>8. 安全 (WS-Security)</h3><ul>
<li><strong>目标</strong>：解决传统HTTP BASIC-Auth和HTTPS的不足，为SOAP消息交换提供端到端的保护。</li>
<li><strong>三大核心问题</strong>：<ol>
<li><strong>认证与授权</strong>：确认用户身份和权限。</li>
<li><strong>消息完整性</strong>：确保消息在传输中未被篡改。</li>
<li><strong>消息加密</strong>：确保消息内容机密性。</li>
</ol>
</li>
<li><strong>实现方式</strong>：通过在SOAP头中添加<code>wsse:Security</code>块，包含：<ul>
<li><strong>用户名令牌</strong> (<code>UsernameToken</code>)：用于基本身份验证。</li>
<li><strong>二进制安全令牌</strong> (<code>BinarySecurityToken</code>)：携带Kerberos、X.509证书等。</li>
<li><strong>数字签名</strong> (<code>Signature</code>)：基于XML Signature标准，保证完整性和不可否认性。</li>
<li><strong>加密数据</strong> (<code>EncryptedData</code>)：基于XML Encryption标准，保证机密性。</li>
</ul>
</li>
</ul>
<h3 id="9-事务与协调-WS-Coordination"><a href="#9-事务与协调-WS-Coordination" class="headerlink" title="9. 事务与协调 (WS-Coordination)"></a>9. 事务与协调 (WS-Coordination)</h3><ul>
<li><strong>目的</strong>：为多参与方、多消息的Web服务交互提供一个通用的<strong>启动和协调</strong>框架。</li>
<li><strong>核心组件</strong>：<ul>
<li><strong>协调者服务</strong>：提供激活、注册、协调协议服务，管理协调任务。</li>
<li><strong>协调上下文</strong>：包含协调者服务的端点引用和任务标识，随业务消息在参与方间传递。</li>
</ul>
</li>
<li><strong>协调类型</strong>：<ul>
<li><strong>原子事务 (WS-AtomicTransaction)</strong>：用于<strong>短时</strong>、<strong>ACID</strong>属性的事务（全有或全无）。适用于高信任域内。</li>
<li><strong>业务活动 (WS-BusinessActivity)</strong>：用于<strong>长时间运行</strong>的业务事务，允许应用业务逻辑处理异常。操作立即生效，通过补偿机制处理失败。</li>
</ul>
</li>
</ul>
<h3 id="10-可靠消息传递-WS-ReliableMessaging"><a href="#10-可靠消息传递-WS-ReliableMessaging" class="headerlink" title="10. 可靠消息传递 (WS-ReliableMessaging)"></a>10. 可靠消息传递 (WS-ReliableMessaging)</h3><ul>
<li><strong>目的</strong>：确保SOAP消息的可靠交换。</li>
<li><strong>保障的特性</strong>：<ol>
<li><strong>保证送达</strong>：发送方未收到确认时会重发。</li>
<li><strong>无重复</strong>：通过消息唯一标识符去重。</li>
<li><strong>顺序保证</strong>：保证消息按发送顺序被处理。</li>
</ol>
</li>
<li><strong>基本原理</strong>：基于“发送-确认”模型，通过SOAP头扩展和特定的故障代码来实现。</li>
</ul>
<h2 id="08-Service-Oriented-Analysis"><a href="#08-Service-Oriented-Analysis" class="headerlink" title="08 Service-Oriented Analysis"></a>08 Service-Oriented Analysis</h2><p>面向服务分析（Service-Oriented Analysis）是面向服务软件工程中的一个核心阶段，其目标是在服务生态系统中识别和定义需要构建的服务，并明确每个服务应封装哪些逻辑。</p>
<h3 id="面向服务分析的目标"><a href="#面向服务分析的目标" class="headerlink" title="面向服务分析的目标"></a>面向服务分析的目标</h3><ol>
<li><strong>识别服务候选</strong>：在业务流程中识别可被抽象为独立服务的逻辑单元。</li>
<li><strong>定义服务操作候选</strong>：为每个服务候选定义具体的操作接口。</li>
<li><strong>分组与语境化</strong>：将服务操作候选分组到逻辑上一致的服务候选（Service Candidate）中。</li>
<li><strong>定义服务边界</strong>：确保新定义的服务不与现有或已规划的服务重叠。</li>
<li><strong>识别复用潜力</strong>：评估服务候选和服务操作候选的可复用性。</li>
<li><strong>定义合成模型</strong>：初步定义服务之间的组合方式。</li>
</ol>
<h3 id="面向服务分析的流程"><a href="#面向服务分析的流程" class="headerlink" title="面向服务分析的流程"></a>面向服务分析的流程</h3><p>面向服务分析遵循一个结构化流程，通常包括以下关键步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1. 分解业务流程</td>
<td>将业务流程拆解为独立的步骤或活动。</td>
</tr>
<tr>
<td>2. 识别业务服务候选逻辑</td>
<td>从流程步骤中识别出适合封装为服务候选的逻辑，排除手工步骤和不可封装的遗留逻辑。</td>
</tr>
<tr>
<td>3. 抽象编排逻辑</td>
<td>识别应由服务编排层处理的逻辑，如业务规则、条件逻辑、异常处理等。</td>
</tr>
<tr>
<td>4. 创建业务服务候选</td>
<td>基于已识别的逻辑创建业务服务候选，并考虑业务中立性。</td>
</tr>
<tr>
<td>5. 提炼和应用面向服务原则</td>
<td>应用如复用、自治等原则，优化服务设计。</td>
</tr>
<tr>
<td>6. 识别服务候选组合</td>
<td>设想通用业务场景，识别服务之间的组合关系。</td>
</tr>
<tr>
<td>7. 修订业务服务候选</td>
<td>根据组合分析结果修订服务候选。</td>
</tr>
<tr>
<td>8. 分析应用处理需求</td>
<td>确定实现服务操作所需的应用逻辑，评估其存在性、开发需求和跨系统边界情况。</td>
</tr>
<tr>
<td>9. 识别应用服务操作候选</td>
<td>识别与业务流程上下文无关的应用级操作。</td>
</tr>
<tr>
<td>10. 创建应用服务候选</td>
<td>基于应用操作候选创建应用服务候选。</td>
</tr>
<tr>
<td>11. 修订服务候选组合</td>
<td>根据应用服务候选修订服务组合。</td>
</tr>
<tr>
<td>12. 修订应用服务候选</td>
<td>最终修订应用服务候选。</td>
</tr>
<tr>
<td>（可选）保存服务候选库存</td>
<td>将服务候选和相关元数据保存到库存中，供后续阶段使用。</td>
</tr>
</tbody></table>
<h3 id="以业务为核心的SOA"><a href="#以业务为核心的SOA" class="headerlink" title="以业务为核心的SOA"></a>以业务为核心的SOA</h3><p>在面向服务分析中，应<strong>以业务服务（Business Services）为核心</strong>，而不是单纯的技术服务（如Web Services）。业务服务能够隔离业务领域和应用领域的变化，促进服务的复用和企业的敏捷性。</p>
<h3 id="常见业务分析方法"><a href="#常见业务分析方法" class="headerlink" title="常见业务分析方法"></a>常见业务分析方法</h3><ul>
<li><strong>业务流程管理（BPM）模型</strong>：是组织业务分析的主要形式，用于描述和优化业务流程。</li>
<li><strong>实体模型</strong>：遵循面向对象规范，用于描述业务领域中的关键实体及其关系。</li>
</ul>
<h3 id="业务服务的派生类型"><a href="#业务服务的派生类型" class="headerlink" title="业务服务的派生类型"></a>业务服务的派生类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>来源</th>
<th>分析工作量</th>
<th>复用潜力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>以任务为核心的业务服务</strong></td>
<td>灵活性高，针对特定业务流程</td>
<td>用例模型、BPM流程定义</td>
<td>较少</td>
<td>有限</td>
</tr>
<tr>
<td><strong>以实体为核心的业务服务</strong></td>
<td>稳定性高，不包含流程逻辑</td>
<td>实体模型</td>
<td>较多</td>
<td>较高</td>
</tr>
</tbody></table>
<h3 id="服务建模原则（部分关键原则）"><a href="#服务建模原则（部分关键原则）" class="headerlink" title="服务建模原则（部分关键原则）"></a>服务建模原则（部分关键原则）</h3><ul>
<li><strong>原则I</strong>：考虑逻辑的跨流程复用性。</li>
<li><strong>原则II</strong>：考虑以任务为核心的服务在流程内的复用潜能。</li>
<li><strong>原则III</strong>：注意与流程相关的依赖因素，这些因素影响服务的灵活性和复用性。</li>
<li><strong>原则IV &amp; V</strong>：应用服务应与业务无关（business-agnostic），支持跨应用复用。</li>
<li><strong>原则VI</strong>：以清晰的边界识别逻辑单元。</li>
<li><strong>原则VII</strong>：避免逻辑边界蔓延（服务之间逻辑重叠）。</li>
<li><strong>原则VIII~XI</strong>：以平衡的模型为目标，综合考虑业务需求、标准和业界约定。</li>
<li><strong>原则XII</strong>：创建和发布业务服务建模标准。</li>
</ul>
<h2 id="09-Service-Oriented-Design"><a href="#09-Service-Oriented-Design" class="headerlink" title="09 Service-Oriented Design"></a>09 Service-Oriented Design</h2><p>面向服务设计（Service-Oriented Design）是将面向服务分析阶段产生的服务候选（逻辑模型）转化为具体的服务设计（物理模型）的过程，并将这些服务装配到实现业务流程的抽象组合中。</p>
<h3 id="面向服务设计的目标"><a href="#面向服务设计的目标" class="headerlink" title="面向服务设计的目标"></a>面向服务设计的目标</h3><ol>
<li><strong>确定架构扩展的核心集合</strong>：识别并选择支持SOA架构所需的核心技术和标准。</li>
<li><strong>设定架构的边界</strong>：明确服务架构的边界和部署环境。</li>
<li><strong>识别所需的设计标准</strong>：制定和遵循一致的设计规范和标准。</li>
<li><strong>定义抽象服务接口设计</strong>：基于服务候选，设计独立于实现细节的抽象服务接口（如WSDL定义）。</li>
<li><strong>识别潜在的服务组合</strong>：分析并设计服务之间的组合关系。</li>
<li><strong>评估面向服务原则的支持</strong>：确保设计符合面向服务原则（如复用性、自治性等）。</li>
<li><strong>探究当代SOA特征的支持</strong>：考虑并集成WS-*等现代SOA标准与扩展。</li>
</ol>
<h3 id="面向服务的设计过程"><a href="#面向服务的设计过程" class="headerlink" title="面向服务的设计过程"></a>面向服务的设计过程</h3><p>面向服务的设计是一个结构化的多步骤过程，核心活动包括：</p>
<ol>
<li><strong>组合SOA</strong>：选择服务层结构、定位核心SOA标准、选择SOA扩展。</li>
<li><strong>设计服务</strong>：具体设计以实体为核心的业务服务、应用服务、以任务为核心的业务服务。</li>
<li><strong>设计面向服务的业务流程</strong>：将业务流程模型转化为可执行的服务编排（如BPEL）。</li>
</ol>
<h3 id="组合SOA——选择服务层"><a href="#组合SOA——选择服务层" class="headerlink" title="组合SOA——选择服务层"></a>组合SOA——选择服务层</h3><p>在设计时需要讨论如何配置服务层，主要考虑以下因素：</p>
<ul>
<li><strong>现有配置</strong>：如果已有标准化的服务层，则在其基础上进行设计。</li>
<li><strong>必需的标准</strong>：如果重新构建，需明确所需的标准。</li>
<li><strong>服务组合性能</strong>：权衡“灵活性”与“性能”。</li>
<li><strong>服务部署</strong>：考虑分布式环境下的性能与冗余。</li>
<li><strong>服务版本控制</strong>：平衡“接口稳定性”与“功能扩展”。</li>
<li><strong>业务服务与XSD Schema设计</strong>：确保与企业模型保持一致。</li>
<li><strong>业务服务维护</strong>：考虑长期维护的便利性。</li>
</ul>
<h3 id="组合SOA——定位核心SOA标准"><a href="#组合SOA——定位核心SOA标准" class="headerlink" title="组合SOA——定位核心SOA标准"></a>组合SOA——定位核心SOA标准</h3><p>应遵循行业标准，尤其是<strong>WS-I基本概要（WS-I Basic Profile）</strong>，它定义了一组确保互操作性的核心Web服务标准，例如：</p>
<ul>
<li><strong>SOAP 1.1</strong></li>
<li><strong>WSDL 1.1</strong></li>
<li><strong>UDDI 2.0</strong></li>
<li><strong>XML 1.0 (Second Edition)</strong></li>
<li><strong>XML Schema</strong></li>
<li><strong>HTTP 1.1</strong>、<strong>TLS</strong>等</li>
</ul>
<p>设计时需遵循WS-I基本概要中的设计准则，例如SOAP信封中不应包含DTD声明、WSDL绑定元素应使用WSDL SOAP绑定等。</p>
<h3 id="组合SOA——选择SOA扩展"><a href="#组合SOA——选择SOA扩展" class="headerlink" title="组合SOA——选择SOA扩展"></a>组合SOA——选择SOA扩展</h3><p>根据项目需求，选择性地引入SOA扩展特征和**WS-<em><strong>标准（如WS-Security、WS-ReliableMessaging等），以及业务流程执行语言</strong>BPEL</em>*。</p>
<h3 id="设计服务"><a href="#设计服务" class="headerlink" title="设计服务"></a>设计服务</h3><p>服务设计过程需要针对不同类型的服务（以实体为核心的业务服务、应用服务、以任务为核心的业务服务）分别进行，但遵循相似的结构化步骤，一般包括：</p>
<ol>
<li>审查现有服务</li>
<li>定义消息Schema类型</li>
<li>提取抽象服务接口</li>
<li>应用面向服务原则</li>
<li>标准化并完善服务接口</li>
<li>识别必要的处理（底层应用逻辑）</li>
<li>最终形成完整的抽象服务定义（WSDL文档）</li>
</ol>
<h3 id="设计以实体为核心的业务服务"><a href="#设计以实体为核心的业务服务" class="headerlink" title="设计以实体为核心的业务服务"></a>设计以实体为核心的业务服务</h3><p><strong>特点</strong>：稳定性高，基于实体模型，复用潜力大。<br><strong>设计步骤</strong>（以“雇员服务”为例）：</p>
<ol>
<li><strong>审查现有服务</strong>：避免功能冗余。</li>
<li><strong>定义消息Schema类型</strong>：设计XSD Schema定义请求&#x2F;响应消息结构（如Employee.xsd, EmployeeHistory.xsd）。</li>
<li><strong>提取抽象服务接口</strong>：在WSDL中定义<code>portType</code>（或<code>interface</code>）和<code>operation</code>，引用XSD Schema类型。</li>
<li><strong>应用面向服务原则</strong>：确保设计支持复用性、自治性、无状态性和可发现性。</li>
<li><strong>标准化并完善服务接口</strong>：应用设计标准，并确保符合WS-I基本概要。</li>
<li><strong>识别必要的处理</strong>：明确底层应用逻辑（如访问账务系统或HR数据库）。</li>
<li><strong>形成最终WSDL定义</strong>：整合所有部分，完成抽象服务设计。</li>
</ol>
<h3 id="设计应用服务"><a href="#设计应用服务" class="headerlink" title="设计应用服务"></a>设计应用服务</h3><p><strong>特点</strong>：与业务无关（business-agnostic），支持跨应用复用。<br><strong>设计步骤</strong>（以“文档转换服务”为例）：</p>
<ol>
<li><strong>审查现有服务</strong>：避免冗余，考虑第三方服务。</li>
<li><strong>确认上下文</strong>：确保操作候选分组合理。</li>
<li><strong>提取初始的服务接口</strong>：定义XSD Schema和WSDL操作。</li>
<li><strong>应用面向服务原则</strong>：重点确保通用性、可复用性和自治性。</li>
<li><strong>标准化并提炼服务接口</strong>：遵循设计标准。</li>
<li><strong>识别技术约束</strong>：考虑性能、安全性、可用性、遗留系统限制等。</li>
<li><strong>形成最终WSDL定义</strong>。</li>
</ol>
<h3 id="设计以任务为核心的业务服务"><a href="#设计以任务为核心的业务服务" class="headerlink" title="设计以任务为核心的业务服务"></a>设计以任务为核心的业务服务</h3><p><strong>特点</strong>：针对特定业务流程，灵活性高，复用性相对有限。<br><strong>设计步骤</strong>（以“发票处理服务”为例）：</p>
<ol>
<li><strong>定义工作流逻辑</strong>：基于业务流程（如活动图）定义执行路径。</li>
<li><strong>提取服务接口</strong>：根据工作流逻辑定义WSDL操作和消息。</li>
<li><strong>应用面向服务原则</strong>：重点考虑自治性和无状态性（常通过文档风格SOAP传递状态）。</li>
<li><strong>标准化并完善服务接口</strong>：遵循设计标准。</li>
<li><strong>识别需要的处理</strong>：确认所需调用的子服务（如实体服务、应用服务）已存在或已设计。</li>
<li><strong>形成最终WSDL定义</strong>：通常复用其他服务的XSD Schema。</li>
</ol>
<h3 id="设计面向服务的业务流程"><a href="#设计面向服务的业务流程" class="headerlink" title="设计面向服务的业务流程"></a>设计面向服务的业务流程</h3><p>目标是将业务流程模型（如BPMN图）转化为可执行的服务编排（如BPEL脚本）。<br><strong>设计步骤</strong>（以“工单提交流程”为例）：</p>
<ol>
<li><strong>刻画交互场景</strong>：基于工作流逻辑和可用服务设计，定义流程的交互路径。</li>
<li><strong>设计流程服务接口</strong>：为流程本身定义WSDL接口（一个启动操作）。</li>
<li><strong>形式化伙伴服务会话</strong>：在参与流程的各服务WSDL中定义<code>partnerLinkType</code>，并在BPEL中定义<code>partnerLink</code>和消息<code>variable</code>。</li>
<li><strong>定义流程逻辑</strong>：使用BPEL活动（如<code>receive</code>, <code>assign</code>, <code>invoke</code>, <code>switch</code>, <code>throw</code>等）实现业务流程逻辑，包括正常流和异常处理（<code>faultHandlers</code>）。</li>
<li><strong>对应交互场景和简化流程（可选）</strong>：优化BPEL定义。</li>
</ol>
<h2 id="10-Principles-of-Service-Oriented-Design"><a href="#10-Principles-of-Service-Oriented-Design" class="headerlink" title="10 Principles of Service-Oriented Design"></a>10 Principles of Service-Oriented Design</h2><h3 id="10-1-Principles-of-Service-Oriented-Design-I"><a href="#10-1-Principles-of-Service-Oriented-Design-I" class="headerlink" title="10.1 Principles of Service-Oriented Design I"></a>10.1 Principles of Service-Oriented Design I</h3><p>面向服务设计的第一组核心原则旨在通过一系列指导方针来定义和塑造服务，以确保服务能够有效支持面向服务架构（SOA）的目标，如提高互操作性、联合性、敏捷性，并降低IT负担。</p>
<h4 id="面向服务设计的原则"><a href="#面向服务设计的原则" class="headerlink" title="面向服务设计的原则"></a>面向服务设计的原则</h4><p>面向服务设计包含以下八项核心原则，它们共同作用以实现高质量的、可持续的服务生态系统：</p>
<ol>
<li><p><strong>标准化服务合约 (Standardized Service Contract)</strong><br>服务必须遵循标准化的合约（如WSDL、XSD）进行描述，以确保服务能力的一致表达和明确的服务上下文。</p>
</li>
<li><p><strong>服务松散耦合 (Service Loose Coupling)</strong><br>服务之间，特别是服务合约与其消费者之间，应最小化依赖关系。这包括减少技术、功能和实现层面的耦合。</p>
</li>
<li><p><strong>服务抽象 (Service Abstraction)</strong><br>应最小化服务元信息（如实现细节）的对外可用性。服务合约应只暴露必要的信息，隐藏内部复杂性。</p>
</li>
<li><p><strong>服务可复用性 (Service Reusability)</strong><br>服务应设计为通用的和可复用的，其封装的逻辑和合约应支持跨多个业务流程的重复使用。</p>
</li>
<li><p><strong>服务自治 (Service Autonomy)</strong><br>服务应具有独立的功能边界和运行时环境，以最大化其对自身处理逻辑的控制权，从而提高可靠性和行为可预测性。</p>
</li>
<li><p><strong>服务无状态性 (Service Statelessness)</strong><br>服务应尽可能设计为无状态的，将状态管理职责外化（如交由客户端或数据库），以增强可扩展性和资源利用率。</p>
</li>
<li><p><strong>服务可发现性 (Service Discoverability)</strong><br>服务应通过充分的、可交流的元数据（如服务描述、策略）进行描述，使其易于在服务注册库中被发现和理解。</p>
</li>
<li><p><strong>服务可组合性 (Service Composability)</strong><br>服务应被设计为可被有效组合的构建块，以支持构建复杂的、组合式的业务流程。</p>
</li>
</ol>
<h4 id="服务合约（标准化与设计）"><a href="#服务合约（标准化与设计）" class="headerlink" title="服务合约（标准化与设计）"></a>服务合约（标准化与设计）</h4><p><strong>标准化服务合约</strong>原则是所有原则的基础，它要求使用形式化和标准化的合约（如WSDL、XML Schema）来定义服务。</p>
<ul>
<li><strong>作用</strong>：建立服务交互的术语，提供技术限制、需求和语义信息。</li>
<li><strong>影响</strong>：其他设计原则（如松散耦合、抽象）会直接影响合约的定位和设计。</li>
<li><strong>关键实践</strong>：<ul>
<li><strong>服务功能描述的标准化</strong>：统一WSDL中操作和消息的命名规范（如动词+名词）。</li>
<li><strong>服务数据表示的标准化</strong>：采用“Schema集中化”模式，为关键业务实体（如客户、订单）定义官方、共享的XML Schema，避免服务间不必要的数据转换，从而提高<strong>内在互操作性</strong>。</li>
<li><strong>服务策略的标准化</strong>：使用WS-Policy等标准来模块化地定义非功能性需求（如安全、可靠性）。</li>
</ul>
</li>
</ul>
<h4 id="服务耦合（服务内及消费者依赖）"><a href="#服务耦合（服务内及消费者依赖）" class="headerlink" title="服务耦合（服务内及消费者依赖）"></a>服务耦合（服务内及消费者依赖）</h4><p><strong>服务松散耦合</strong>原则强调减少服务解决方案各部分之间的依赖，特别是在服务合约与其消费者之间。</p>
<ul>
<li><strong>耦合类型</strong>：<ul>
<li><strong>“逻辑-合约”耦合</strong>：服务逻辑依赖于服务合约（“合约优先”设计的结果）。这是积极耦合，允许在保持接口稳定的情况下更换底层实现。</li>
<li><strong>“合约-逻辑”耦合</strong>：服务合约从现有实现逻辑（如数据库、API）自动生成。这被视为反模式，会导致紧密的技术和实现耦合，限制服务演化。</li>
<li><strong>“合约-技术”耦合</strong>：合约与特定通信技术（如专有RPC）绑定，限制了潜在消费者。</li>
<li><strong>“合约-实现”耦合</strong>：合约中暴露了物理实现细节（如服务器名、文件路径），将消费者与特定环境绑定。</li>
<li><strong>“合约-功能”耦合</strong>：合约专为支持某个特定外部业务流程而设计，降低了通用性。</li>
</ul>
</li>
<li><strong>消费者耦合类型</strong>：<ul>
<li><strong>“消费者-合约”耦合</strong>：消费者通过标准化的服务合约访问服务，这是形成松散耦合关系的基础。</li>
<li><strong>“消费者-实现”耦合</strong>：消费者绕过服务合约，直接访问服务内部实现（如数据库），这应极力避免。</li>
</ul>
</li>
<li><strong>设计影响</strong>：<ul>
<li><strong>与粒度的关系</strong>：耦合程度影响操作和数据的粒度选择。过粗或过细的粒度都可能增加不必要的依赖或性能开销。</li>
<li><strong>与服务模型的关系</strong>：以实体为核心的服务天然与业务实体耦合，但应与其他逻辑解耦；应用服务可能带有实现耦合；以任务为核心的服务可能存在有意的功能耦合。</li>
</ul>
</li>
<li><strong>主要目标</strong>：通过<strong>合约集中化</strong>（强制所有访问必须通过标准合约）并结合标准化设计，最大化“消费者-合约”耦合，同时最小化所有其他形式的“消极耦合”，从而提高服务的独立性、演化能力和复用潜力。</li>
</ul>
<h3 id="10-2-Principles-of-Service-Oriented-Design-II"><a href="#10-2-Principles-of-Service-Oriented-Design-II" class="headerlink" title="10.2 Principles of Service-Oriented Design II"></a>10.2 Principles of Service-Oriented Design II</h3><p>本部分涵盖面向服务设计的第二组核心原则，侧重于服务的<strong>抽象</strong>与<strong>复用</strong>能力，这些原则确保服务既能隐藏复杂性以支持长期演化，又能最大化其价值。</p>
<h4 id="服务抽象（信息隐藏与元抽象类型）"><a href="#服务抽象（信息隐藏与元抽象类型）" class="headerlink" title="服务抽象（信息隐藏与元抽象类型）"></a>服务抽象（信息隐藏与元抽象类型）</h4><p><strong>服务抽象原则</strong>旨在平衡服务所发布的信息量：既要提供足够的细节以使服务可被理解和使用，又要隐藏不必要的内部信息以<strong>保护服务的演化能力</strong>并最小化与服务消费者之间的耦合。</p>
<ul>
<li><strong>核心目标</strong>：避免不必要服务信息（元信息或其他信息）的扩散。合约中发布的信息越多，形成的“消费者-合约”耦合就越深，甚至可能间接导致“消费者-实现”耦合。</li>
<li><strong>抽象的元信息类型</strong>：<ul>
<li><strong>技术信息</strong>：隐藏编程语言、系统资源等底层技术细节，允许自由地进行技术变更。</li>
<li><strong>功能信息</strong>：通过技术合约（如WSDL）仅暴露必要的服务能力。</li>
<li><strong>程序逻辑信息</strong>：故意对外界隐藏服务的内部设计规范和源代码细节。</li>
<li><strong>服务质量信息</strong>：通过SLA、策略文档等描述服务的行为、限制和可靠性要求，这部分信息通常需要选择性发布。</li>
</ul>
</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>抽象 vs. 封装</strong>：封装定义了服务边界内的逻辑和资源；抽象决定了这些被封装内容中有多少暴露给外部。良好的抽象允许改变内部实现而不影响现有消费者。</li>
<li><strong>抽象与粒度</strong>：抽象倾向于减少合约中的细节约束（粗粒度约束），以给予服务所有者最大的演化自由。但使用策略（Policy）时可能暴露更多细节。</li>
<li><strong>与服务模型</strong>：以实体为核心的服务和应用服务通常能实现较高的抽象级别；而以任务为核心的服务和编排服务由于与具体业务流程绑定，抽象级别往往受限。</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>多消费者耦合需求</strong>：不同消费者可能需要不同粒度的接口细节，可通过“合约反规范化”提供多重接口。</li>
<li><strong>人为误判</strong>：过于抽象导致服务无法被理解；过于具体导致消费者对实现作出假设。</li>
<li><strong>安全与隐私</strong>：需防止合约暴露敏感信息，可根据环境（内部&#x2F;外部）调整抽象级别。</li>
</ul>
</li>
</ul>
<h4 id="服务可复用性（商业与无关设计）"><a href="#服务可复用性（商业与无关设计）" class="headerlink" title="服务可复用性（商业与无关设计）"></a>服务可复用性（商业与无关设计）</h4><p><strong>服务可复用性原则</strong>倡导通过重复使用服务来最大化每个软件单元的价值，其核心是设计通用的、<strong>与业务无关的服务</strong>，使其能够支持多个业务流程。</p>
<ul>
<li><strong>复用的层次</strong>：从单一目的程序，到多目的程序，再到面向服务所倡导的、高度无关的、作为企业资产的可复用服务。</li>
<li><strong>无关服务</strong>：指那些与特定业务流程、技术或应用平台保持中立（无关）的服务。服务越无关，其复用潜力就越大。</li>
<li><strong>关键支撑模式</strong>：<ul>
<li><strong>服务库存蓝图</strong>：规划服务库存的顶层结构，以系统化地识别和定义无关服务。</li>
<li><strong>逻辑集中化</strong>：要求当解决方案需要某项功能时，必须调用服务库存中<strong>指定的、唯一的</strong>服务（该服务是该功能的官方提供者）。这消除了功能冗余，是复用和标准化的基础。</li>
<li><strong>合约集中化</strong>：要求所有服务访问必须通过其发布的、标准化的合约进行。逻辑集中化（<strong>调用哪个服务</strong>）和合约集中化（<strong>如何调用服务</strong>）结合，是确保复用和互操作性的基石。</li>
</ul>
</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>与服务建模</strong>：在分析阶段就应考虑复用潜力，精化服务候选使其更通用，甚至定义超出当前业务流程需求的额外能力候选。</li>
<li><strong>与粒度</strong>：<ul>
<li><strong>服务粒度</strong>：倾向于细粒度服务（更专注，更易复用）。</li>
<li><strong>能力粒度</strong>：需平衡：粗粒度能力（多合一）更通用但可能带来不必要的数据处理；细粒度能力更灵活但可能导致多次调用。常需提供多重粒度版本。</li>
<li><strong>数据&#x2F;约束粒度</strong>：倾向于更粗的数据粒度和更少的详细验证约束，以降低消费者使用门槛。</li>
</ul>
</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>文化阻力</strong>：项目团队可能不愿使用他人创建的服务，或不愿投入额外精力构建可被他人复用的服务。</li>
<li><strong>治理负担</strong>：可复用服务作为共享资产，需要更严格的生命周期管理、版本控制和变更控制。</li>
<li><strong>单点失效</strong>：一个被广泛复用的关键服务若发生故障，将影响多个业务流程。需通过高可用设计缓解。</li>
<li><strong>安全复杂性</strong>：不同使用场景可能对同一服务提出不同的安全要求。</li>
<li><strong>与敏捷交付的冲突</strong>：构建高度可复用的服务需要更多前期分析和设计，可能与追求快速交付的敏捷方法产生矛盾。</li>
</ul>
</li>
</ul>
<h3 id="10-3-Principles-of-Service-Oriented-Design-III"><a href="#10-3-Principles-of-Service-Oriented-Design-III" class="headerlink" title="10.3 Principles of Service-Oriented Design III"></a>10.3 Principles of Service-Oriented Design III</h3><p>本部分涵盖面向服务设计的第三组核心原则，侧重于服务的<strong>自治</strong>与<strong>状态管理</strong>，这些原则直接影响服务的运行时质量、可靠性和可扩展性。</p>
<h4 id="服务自治（处理边界与控制）"><a href="#服务自治（处理边界与控制）" class="headerlink" title="服务自治（处理边界与控制）"></a>服务自治（处理边界与控制）</h4><p><strong>服务自治原则</strong>强调服务应作为独立的构成单元，对其执行环境拥有高度的控制权，以提升可靠性、行为可预测性和性能。</p>
<ul>
<li><strong>自治类型</strong>：<ul>
<li><strong>运行时自治</strong>：服务在执行时对自身处理逻辑和资源的控制级别。高运行时自治带来更高的性能可靠性和可预测性。</li>
<li><strong>设计时自治</strong>：服务所有者修改和演化服务的自由度。高设计时自治支持服务适应新需求和技术。</li>
</ul>
</li>
<li><strong>自治级别（由低到高）</strong>：<ul>
<li><strong>共享自治</strong>：服务与其它应用共享底层资源（如数据库），自治性最低。</li>
<li><strong>服务逻辑自治（部分隔离）</strong>：服务拥有专用处理逻辑，但共享数据存储等资源。</li>
<li><strong>完全自治（隔离）</strong>：服务拥有专有的逻辑和运行时环境（包括数据库、服务器），达到最高级别的自治。</li>
</ul>
</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>服务合约自治</strong>：通过服务规范化（消除功能重叠）来保证。这是实现其他级别自治的基础。</li>
<li><strong>与服务模型</strong>：实体服务作为核心可复用资产，最应追求高自治级别（甚至完全隔离）。应用服务可能因封装遗留系统而具有混合自治级别。任务&#x2F;编排服务的自治性取决于其组合成员的集体自治性。</li>
<li><strong>与粒度</strong>：追求高自治性常导致服务能力被拆分到更专注、更细粒度的服务中，以隔离和控制关键资源。</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>范围误判</strong>：一旦服务被部署到隔离环境，错误定义的服务范围很难更改。</li>
<li><strong>遗留系统封装</strong>：封装的遗留逻辑常常无法定制，会严重限制服务的自治性。</li>
<li><strong>过高估计需求</strong>：实现高自治（如专用服务器）成本高昂，需仔细评估投资回报。</li>
</ul>
</li>
</ul>
<h4 id="服务无状态性（状态管理延迟与无状态性设计）"><a href="#服务无状态性（状态管理延迟与无状态性设计）" class="headerlink" title="服务无状态性（状态管理延迟与无状态性设计）"></a>服务无状态性（状态管理延迟与无状态性设计）</h4><p><strong>服务无状态性原则</strong>倡导服务应尽量不管理会话状态，将状态管理职责<strong>委托</strong>给架构或<strong>延迟</strong>到必要时，以最大化服务的可扩展性和资源利用率。</p>
<ul>
<li><strong>核心思想</strong>：服务应尽可能保持“无状态”条件，避免在内存中长时间保持活动特定的临时数据，从而能快速释放资源以服务更多请求。</li>
<li><strong>状态管理策略</strong>：<ul>
<li><strong>状态委托</strong>：将状态数据交给调用方（消费者）管理。</li>
<li><strong>状态延迟</strong>：将状态数据临时存储到服务外部的、共享的持久化介质中（如状态数据库、消息队列）。</li>
</ul>
</li>
<li><strong>无状态性级别（由低到高）</strong>：<ul>
<li><strong>非延迟状态管理</strong>：服务在整个活动期间保持所有状态数据（完全有状态）。</li>
<li><strong>部分延迟状态管理</strong>：服务能卸载部分状态数据，减少内存占用。</li>
<li><strong>完全架构状态管理延迟</strong>：服务最大限度地利用外部存储延迟状态，大部分时间处于无状态。</li>
</ul>
</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>消息作为状态载体</strong>：可以通过精心设计的消息（包括SOAP头）在服务间传递业务和上下文数据，从而减轻服务的状态管理负担。</li>
<li><strong>与服务模型</strong>：<ul>
<li><strong>实体&#x2F;应用服务</strong>：应力争高度无状态，并标准化状态数据的表示和传递方式。</li>
<li><strong>任务&#x2F;编排服务</strong>：由于其业务流程协调者的角色，通常需要管理流程上下文，因此常被设计为有状态的。但应利用状态延迟机制来优化资源使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>架构依赖</strong>：引入外部状态存储（如数据库）会形成新的依赖，需权衡其带来的好处。</li>
<li><strong>性能开销</strong>：在状态延迟和恢复过程中，数据的存储、检索和解析会引入额外的运行时开销。</li>
<li><strong>实现复杂性</strong>：支持灵活的状态延迟机制需要更复杂的设计、编程和测试。</li>
</ul>
</li>
</ul>
<h3 id="10-4-Principles-of-Service-Oriented-Design-IV"><a href="#10-4-Principles-of-Service-Oriented-Design-IV" class="headerlink" title="10.4 Principles of Service-Oriented Design IV"></a>10.4 Principles of Service-Oriented Design IV</h3><p>本部分涵盖面向服务设计的最后两组原则，侧重于服务的<strong>可发现性</strong>与<strong>可组合性</strong>，这些原则确保服务能够被有效定位、理解并装配成更复杂的解决方案。</p>
<h4 id="服务可发现性（可解释性与交流）"><a href="#服务可发现性（可解释性与交流）" class="headerlink" title="服务可发现性（可解释性与交流）"></a>服务可发现性（可解释性与交流）</h4><p><strong>服务可发现性原则</strong>要求服务应配备充分的<strong>元数据</strong>，并使其易于被<strong>发现</strong>和<strong>理解</strong>，以便在服务库存中定位能够满足特定自动化需求的服务。</p>
<ul>
<li><strong>核心概念</strong>：<ul>
<li><strong>发现</strong>：基于统一元信息，在服务库存中搜索和定位服务的过程。</li>
<li><strong>可解释性</strong>：被发现的服务的元信息（目的、能力）能够被清晰理解的质量。</li>
</ul>
</li>
<li><strong>元信息类型</strong>：<ul>
<li><strong>功能性元数据</strong>：描述服务“能做什么”。通过标准化的服务合约和清晰的文档（如服务概要）来表达。</li>
<li><strong>服务质量元数据</strong>：描述服务“表现如何”，如性能、可用性、策略等。通过SLA、WS-Policy等表达。</li>
</ul>
</li>
<li><strong>发现类型</strong>：<ul>
<li><strong>设计时发现</strong>：由开发&#x2F;设计人员手动在服务注册库中查找服务。</li>
<li><strong>运行时发现</strong>：由程序动态查询并绑定服务（更复杂，较少见）。</li>
</ul>
</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>平衡的挑战</strong>：需在<strong>服务抽象</strong>（隐藏信息）和<strong>服务可发现性</strong>（提供信息）之间取得平衡。关键信息必须发布，但实现细节应隐藏。</li>
<li><strong>与其他原则</strong>：服务可发现性主要服务于<strong>服务可复用性</strong>和<strong>服务可组合性</strong>，使潜在的复用和组合机会不被错过。</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>事后补充元数据</strong>：在服务开发完成后才补充元数据，通常质量较差。应在设计阶段早期创建。</li>
<li><strong>交流不畅</strong>：由不擅长沟通的技术或业务人员单独创建的元数据，可能难以被其他人理解。</li>
</ul>
</li>
</ul>
<h4 id="服务可组合性（组合成员设计与复杂组合）"><a href="#服务可组合性（组合成员设计与复杂组合）" class="headerlink" title="服务可组合性（组合成员设计与复杂组合）"></a>服务可组合性（组合成员设计与复杂组合）</h4><p><strong>服务可组合性原则</strong>要求服务被设计为有效的、可重复使用的<strong>组合成员</strong>，能够被组装成更复杂的服务组合，以解决更大的业务问题。它是面向服务计算的基石。</p>
<ul>
<li><strong>核心概念</strong>：<ul>
<li><strong>服务组合</strong>：在设计时定义的、为支持业务流程而将多个服务能力组装在一起的逻辑。</li>
<li><strong>组合角色</strong>：<ul>
<li><strong>组合控制器</strong>：位于组合顶端的服务，负责协调工作流（通常是任务服务或编排服务）。</li>
<li><strong>组合成员</strong>：被控制器或其他成员调用的服务。</li>
<li><strong>指定控制器</strong>：专门设计为只能担任控制器角色的服务。</li>
</ul>
</li>
</ul>
</li>
<li><strong>组合质量</strong>：一个服务组合的整体质量（如性能、可靠性）取决于其所有成员服务质量的<strong>集体度量</strong>。组合控制器的自治性会受到其调用的、自治性较低的成员的拖累。</li>
<li><strong>与服务设计的关系</strong>：<ul>
<li><strong>与粒度</strong>：粒度直接影响组合效率。细粒度服务&#x2F;能力导致更多调用次数；粗粒度数据导致网络传输量增大。需要权衡。</li>
<li><strong>与服务模型</strong>：<ul>
<li><strong>实体&#x2F;应用服务</strong>：通常作为组合成员，追求高可组合性。</li>
<li><strong>任务服务</strong>：可担任组合成员、子控制器或指定控制器。</li>
<li><strong>编排服务</strong>：通常是复杂的、长期的组合控制器。</li>
</ul>
</li>
<li><strong>与服务编排</strong>：使用BPEL等编排语言能更灵活、更声明式地定义复杂组合。</li>
</ul>
</li>
<li><strong>与其他原则的紧密联系</strong>：<ul>
<li>可组合性高度依赖于其他所有原则的实现程度。例如，需要<strong>标准化合约</strong>以确保互操作，需要<strong>松散耦合</strong>以减少组合约束，需要<strong>高自治</strong>和<strong>无状态</strong>的成员来保证组合的效率和可靠性。</li>
</ul>
</li>
<li><strong>主要风险</strong>：<ul>
<li><strong>单点故障与性能瓶颈</strong>：一个被广泛组合的关键服务如果失效或性能低下，会拖累所有包含它的组合。</li>
<li><strong>治理复杂度</strong>：“过度复用”的服务一旦需要变更，会影响到大量组合，需要进行严格的变更影响分析和版本管理。</li>
</ul>
</li>
</ul>
<h2 id="11-Development-Testing-Deployment-and-management-of-Services"><a href="#11-Development-Testing-Deployment-and-management-of-Services" class="headerlink" title="11 Development, Testing, Deployment and management of Services"></a>11 Development, Testing, Deployment and management of Services</h2><p>本章节介绍面向服务软件工程中，服务分析设计之后的关键生命周期阶段：开发、测试、部署与管理。</p>
<h3 id="服务的开发"><a href="#服务的开发" class="headerlink" title="服务的开发"></a>服务的开发</h3><p>在完成面向服务设计与服务建模后，进入具体实现阶段。</p>
<ul>
<li><strong>实现方式</strong>：<ol>
<li><strong>开发定制服务</strong>：使用特定编程语言（如Java, C#）在特定平台（如Java EE， .NET）上从头开发服务逻辑。</li>
<li><strong>包装遗留系统</strong>：将现有遗留应用或系统的功能通过服务适配器（Service Adapter）封装成标准服务接口，是集成旧有资产的关键手段。</li>
<li><strong>构建应用系统</strong>：开发全新的、基于服务架构的应用程序。</li>
</ol>
</li>
<li><strong>主要平台与厂商</strong>：Java EE, .NET; Microsoft, IBM, Oracle等。</li>
</ul>
<h3 id="服务的测试"><a href="#服务的测试" class="headerlink" title="服务的测试"></a>服务的测试</h3><p>服务测试面临独特挑战，如消费者未知、源码不可见等，因此测试重点从“代码”转向“规约”。</p>
<ul>
<li><strong>测试关注点（关键问题）</strong>：<ul>
<li>服务潜在访问者类型？</li>
<li>是否满足所有服务策略断言？</li>
<li>面对异常情况的表现？</li>
<li>服务描述（WSDL等）是否准确表达了语义？</li>
<li>是否遵循WS-I基本概要以确保互操作性？</li>
<li>服务组合与发现的简易程度？</li>
<li>新服务是否符合既有设计规范？</li>
<li>是否引入了架构不支持的新功能或QoS需求？</li>
</ul>
</li>
<li><strong>面向服务测试的特点</strong>：<ul>
<li><strong>基于规约的测试</strong>：主要依据公开的服务合约（WSDL, Policy）进行测试，而非源码。</li>
<li><strong>动态性测试</strong>：关注服务在运行时的行为、组合表现及异常处理。</li>
<li><strong>协同测试</strong>：强调服务提供者、代理（注册中心）和消费者之间的协同验证与确认。</li>
</ul>
</li>
<li><strong>测试方法</strong>：<ul>
<li><strong>CV&amp;V (协同验证与确认)</strong>：多方协作的测试过程。</li>
<li><strong>WebStrar</strong>：一种支持Web服务测试资产（如测试用例、可靠性模型）发布、排名与管理的框架。</li>
</ul>
</li>
</ul>
<h3 id="服务的部署"><a href="#服务的部署" class="headerlink" title="服务的部署"></a>服务的部署</h3><p>将开发测试完成的服务发布到运行环境，需考虑架构、性能、集成与运维等。</p>
<ul>
<li><strong>部署关键问题</strong>：<ul>
<li><strong>分布与基础设施</strong>：服务如何分布？基础设施能否满足所有服务的处理需求？</li>
<li><strong>集成影响</strong>：新服务对现有服务和应用的影响？</li>
<li><strong>复用服务定位</strong>：如何定位和部署在多个解决方案中复用的服务？</li>
<li><strong>中间件影响</strong>：引入中间件对现有环境的影响？</li>
<li><strong>版本管理</strong>：新版本服务是否需要与旧版本并行部署？</li>
<li><strong>安全与扩展</strong>：所需的安全设置、账号管理，以及如何维护服务池以适应扩展需求？</li>
<li><strong>遗留系统管理</strong>：如何维护和监管封装了遗留系统的服务？</li>
</ul>
</li>
</ul>
<h3 id="服务的管理"><a href="#服务的管理" class="headerlink" title="服务的管理"></a>服务的管理</h3><p>服务上线后，需要持续的管理和治理以确保其持续、有效、安全地运行。</p>
<ul>
<li><strong>管理关注点</strong>：<ul>
<li><strong>使用监管</strong>：如何监控服务的使用情况、性能和SLA合规性？</li>
<li><strong>版本控制</strong>：如何管理服务描述文档（WSDL, Schema）的版本和变更？</li>
<li><strong>消息跟踪</strong>：如何跟踪和管理服务间的消息交换，用于调试和审计？</li>
<li><strong>性能监控</strong>：如何检测和诊断性能瓶颈？</li>
<li><strong>生命周期管理</strong>：涵盖服务从部署、运维到退役的全过程管理。</li>
</ul>
</li>
</ul>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h3 id="12-01-Web-Services-Platform-Architecture"><a href="#12-01-Web-Services-Platform-Architecture" class="headerlink" title="12.01 Web Services Platform Architecture"></a>12.01 Web Services Platform Architecture</h3><p>本章节介绍Web服务平台架构（WSPA）的核心组成部分，这是理解Web服务如何被部署和调用的技术基础。</p>
<h4 id="Web-Services-Platform-Architecture"><a href="#Web-Services-Platform-Architecture" class="headerlink" title="Web Services Platform Architecture"></a>Web Services Platform Architecture</h4><p>一个Web服务平台是一套使用特定编程语言（如Java）来<strong>调用</strong>和<strong>部署</strong>Web服务的工具集。它包含<strong>服务器端组件</strong>（通常打包在容器中，如Java EE应用服务器）和<strong>客户端组件</strong>（通常作为访问服务的工具包）。任何Web服务平台都必须提供三个核心子系统：</p>
<ol>
<li><p><strong>调用子系统 (Invocation Subsystem)</strong></p>
<ul>
<li><strong>服务器端调用</strong>：处理从传输层（如HTTP）接收SOAP请求、预处理消息、确定目标服务和WSDL操作、分派到具体的Java类&#x2F;方法、反序列化参数、调用Java目标、序列化返回结果并包装成SOAP响应、处理异常并生成SOAP Fault。</li>
<li><strong>客户端调用</strong>：创建实现服务端点接口（SEI）的代理实例；序列化Java参数为符合WSDL的XML；包装成SOAP消息；进行后处理；通过传输层发送请求；接收并处理SOAP响应。</li>
</ul>
</li>
<li><p><strong>序列化子系统 (Serialization Subsystem)</strong></p>
<ul>
<li><strong>核心功能</strong>：在Java对象和XML元素之间进行<strong>序列化</strong>（Java -&gt; XML）和<strong>反序列化</strong>（XML -&gt; Java）。</li>
<li><strong>映射策略</strong>：定义了Java类如何映射到目标XML Schema组件的规则，称为<strong>类型映射</strong>。序列化引擎需要一套<strong>映射策略</strong>来实现这些映射。</li>
<li><strong>实现机制</strong>：<ul>
<li><strong>标准绑定</strong>：由JAXB&#x2F;JAX-WS规范预定义Java类到XML Schema的映射。</li>
<li><strong>源码注解</strong>：通过在Java类源码中添加注解（如JAX-WS, JAXB注解）来自定义标准绑定。</li>
<li><strong>算法式</strong>：映射逻辑内嵌在序列化子系统的算法中（如JAX-RPC 1.1）。</li>
<li><strong>规则式</strong>：通过独立于系统的映射规则文件（如Castor框架的映射文件）来定义。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>部署子系统 (Deployment Subsystem)</strong></p>
<ul>
<li><strong>核心功能</strong>：提供将Java目标（如一个Java类或EJB）配置为可通过SOAP消息调用的Web服务的工具。</li>
<li><strong>主要职责</strong>：<ul>
<li>部署Java目标到容器（如部署无状态会话Bean到EJB容器）。</li>
<li>映射WSDL操作到Java目标方法。</li>
<li>定义<strong>序列化上下文</strong>（一组映射策略）。</li>
<li>发布WSDL。</li>
<li>配置SOAP处理器（Handler）以提供QoS支持。</li>
<li>配置端点监听器。</li>
</ul>
</li>
<li><strong>部署描述符</strong>：用于配置上述各种对象和依赖的XML文件，随着配置复杂度增加，管理变得困难，常需可视化工具辅助。</li>
</ul>
</li>
</ol>
<h3 id="12-02-JWS-Architecture"><a href="#12-02-JWS-Architecture" class="headerlink" title="12.02 JWS Architecture"></a>12.02 JWS Architecture</h3><p>本章节介绍Java Web服务（JWS）架构，这是基于Java EE标准的具体Web服务平台实现，核心是<strong>JAX-WS</strong>、<strong>JAXB</strong>和<strong>WS-Metadata</strong>等规范。</p>
<h4 id="JWS-Architecture"><a href="#JWS-Architecture" class="headerlink" title="JWS Architecture"></a>JWS Architecture</h4><p>JWS是Java平台上构建Web服务的标准体系，旨在简化开发和部署。</p>
<ul>
<li><p><strong>服务器端部署与调用流程</strong>：</p>
<ol>
<li><strong>部署</strong>：将<strong>Port组件</strong>（Web服务的服务器端视图）打包为WAR（Servlet端点）或EJB JAR（EJB端点）。WSEE规范定义了部署过程和打包结构。</li>
<li><strong>WSDL生成与定制</strong>：WSDL结构由JAX-WS的WSDL&#x2F;Java标准映射决定，可通过<strong>注解</strong>进行定制（JAX-WS注解定制WSDL风格，JAXB注解定制XML表示，WS-Metadata注解定制WSDL细节）。</li>
<li><strong>端点监听</strong>：部署时，WSEE运行时会根据注解&#x2F;部署描述符读取配置，并在指定URL部署一个Servlet端点监听器。</li>
<li><strong>请求处理</strong>：当SOAP请求到达时，JAX-WS运行时提取XML参数，<strong>JAXB运行时</strong>根据注解和标准绑定将XML反序列化为Java参数。</li>
<li><strong>业务调用</strong>：调用目标Java方法。</li>
<li><strong>响应生成</strong>：JAXB将Java返回值序列化为XML，JAX-WS将其包装为SOAP响应并返回。<br>（注：处理器调用和异常处理在图中省略，但实际存在）。</li>
</ol>
</li>
<li><p><strong>客户端调用流程</strong>：</p>
<ol>
<li><strong>生成SEI</strong>：编译客户端应用前，使用WSDL-to-Java工具生成<strong>服务端点接口</strong>。</li>
<li><strong>获取代理</strong>：运行时，通过<code>javax.xml.ws.Service</code>类的实例获取SEI的代理实例。</li>
<li><strong>方法调用</strong>：调用代理实例上的SEI方法，JAX-WS和JAXB会根据注解将参数序列化为SOAP请求。</li>
<li><strong>处理器处理</strong>：发送前，调用配置的处理器（Handler）进行预处理（如可靠性、安全）。</li>
<li><strong>发送与接收</strong>：发送SOAP请求，接收SOAP响应。</li>
<li><strong>响应处理</strong>：处理器后处理，JAXB反序列化响应XML为Java对象，作为方法返回值。</li>
</ol>
</li>
<li><p><strong>开发模式</strong>：</p>
<ul>
<li><strong>SFJ (Start from Java)</strong>：<strong>从Java开始</strong>。先编写Java类，通过添加<code>@WebService</code>等注解将其部署为Web服务。平台自动生成WSDL。最简单，但生成的WSDL可能不符合特定标准。</li>
<li><strong>SFW (Start from WSDL)</strong>：<strong>从WSDL开始</strong>。已有预定义的WSDL契约，使用工具生成SEI骨架，开发者实现业务逻辑。利于遵循标准契约。</li>
<li><strong>SFWJ (Start from WSDL and Java)</strong>：<strong>从WSDL和Java开始</strong>。需要将现有的Java类映射到现有的WSDL契约。这是<strong>系统集成中最常见也最困难的场景</strong>，JWS工具对此支持有限，常需通过<strong>包装器代码</strong>或复杂的注解映射来桥接，易导致代码复杂和难以维护。</li>
</ul>
</li>
<li><p><strong>JWS核心规范与权衡</strong>：</p>
<ul>
<li><strong>JAX-WS 2.0</strong>：定义了调用子系统、部分部署和序列化逻辑，是JAX-RPC的后继者。</li>
<li><strong>JAXB 2.0</strong>：定义了Java与XML Schema之间的标准数据绑定，简化了XML处理。</li>
<li><strong>WS-Metadata 2.0</strong>：定义了用于Web服务部署的注解。</li>
<li><strong>WSEE 1.2</strong>：定义了Web服务在Java EE服务器上的部署架构和打包，确保可移植性。</li>
<li><strong>核心权衡</strong>：JWS通过标准映射和注解极大地<strong>简化了开发</strong>（尤其是SFJ模式），但牺牲了<strong>灵活性</strong>。当需要将现有Java系统映射到严格定义的行业标准WSDL（SFWJ模式）时，工具支持不足，可能无法生成“有用”的服务，或迫使开发者编写繁琐的适配代码。</li>
</ul>
</li>
</ul>
</article><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/12/23/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">HCI</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">面向服务的软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Services-and-Services-System"><span class="toc-number">1.1.</span> <span class="toc-text">01 Services and Services System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、 服务的定义与本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%A7%E5%93%81%EF%BC%88%E5%88%B6%E9%80%A0%EF%BC%89%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、 服务与产品（制造）模型的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">三、 服务系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. 主要组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9A%E8%A7%86%E8%A7%92%E8%A7%82%E5%AF%9F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. 多视角观察</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-IT%E8%B5%8B%E8%83%BD%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">四、 IT赋能的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1. 核心关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2. 主要模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IT%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%9D%9EIT%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3. IT服务与非IT服务的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%BA%93%E5%AD%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">五、 服务生态系统与服务库存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 服务生态系统概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. 核心挑战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Services-Computing-and-Service-Oriented"><span class="toc-number">1.2.</span> <span class="toc-text">02 Services Computing and Service-Oriented</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E8%BD%AF%E4%BB%B6%E8%8C%83%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、 软件范型的演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%EF%BC%88Service-Oriented%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、 面向服务（Service-Oriented）的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B1%82%E4%B8%8E%E5%88%86%E5%B7%A5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. 服务分层与分工</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%BA%93%E5%AD%98%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%BB%84%E5%90%88"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. 服务库存与服务组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1-vs-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、 面向服务 vs. 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 基本概念映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E9%80%82%E7%94%A8%E6%80%A7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. 设计原则的适用性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E6%9C%8D%E5%8A%A1%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">四、 服务计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">五、 关键技术概念与架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%EF%BC%88SOA%EF%BC%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1. 面向服务的架构（SOA）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90%E4%B8%8E%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2. 企业应用集成与业务流程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3. 关键实现技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.6.</span> <span class="toc-text">六、 面向服务总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-Service-Oriented-Architecture"><span class="toc-number">1.3.</span> <span class="toc-text">03 Service-Oriented Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-SOA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">一、 SOA核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-SOA%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.2.</span> <span class="toc-text">二、 SOA的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-SOA%E7%9A%84%E5%A4%9A%E5%B1%82%E6%AC%A1%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">三、 SOA的多层次视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%EF%BC%88ESB%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">四、 企业服务总线（ESB）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-SOA%E5%8F%82%E8%80%83%E6%9E%B6%E6%9E%84%EF%BC%88SOA-RA%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">五、 SOA参考架构（SOA-RA）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B0%B4%E5%B9%B3%E5%B1%82%EF%BC%88%E5%8A%9F%E8%83%BD%E5%B1%82%EF%BC%89"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">1. 水平层（功能层）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9E%82%E7%9B%B4%E5%B1%82%EF%BC%88%E6%94%AF%E6%92%91%E5%B1%82%EF%BC%89"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">2. 垂直层（支撑层）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81-SOA%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">六、 SOA实践与生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-Message-exchange-and-Data-type"><span class="toc-number">1.4.</span> <span class="toc-text">04 Message exchange and Data type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%EF%BC%88Electronic-Information-Exchange%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">一、 电子信息交换（Electronic Information Exchange）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-XML-eXtensible-Markup-Language"><span class="toc-number">1.4.2.</span> <span class="toc-text">二、 XML (eXtensible Markup Language)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. 核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%BC%E5%BC%8F%E8%89%AF%E5%A5%BD%EF%BC%88Well-formed%EF%BC%89XML"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. 格式良好（Well-formed）XML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. 字符数据处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%BC%E5%BC%8F%E8%89%AF%E5%A5%BD-vs-%E6%9C%89%E6%95%88%EF%BC%88Valid%EF%BC%89"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4. 格式良好 vs. 有效（Valid）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88NameSpace%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">三、 命名空间（NameSpace）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2. 关键概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-XML%E6%A8%A1%E5%BC%8F%EF%BC%88XML-Schema%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">四、 XML模式（XML Schema）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">1. 作用与特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">2. 核心元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">3. 模式定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-XPath"><span class="toc-number">1.4.5.</span> <span class="toc-text">五、 XPath</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">1. 核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">2. 路径表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E6%89%A9%E5%B1%95%E6%A0%B7%E5%BC%8F%E8%A1%A8%E8%AF%AD%E8%A8%80%E5%AE%B6%E6%97%8F%EF%BC%88XSL%EF%BC%89"><span class="toc-number">1.4.6.</span> <span class="toc-text">六、 扩展样式表语言家族（XSL）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-XSLT-XSL-Transformations"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">1. XSLT (XSL Transformations)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-XPath"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">2. XPath</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81-XML%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">七、 XML解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DOM-Document-Object-Model-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">1. DOM (Document Object Model) 解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SAX-Simple-API-for-XML-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">2. SAX (Simple API for XML) 解析器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%88%E7%BA%A6"><span class="toc-number">1.4.8.</span> <span class="toc-text">八、 数据表示标准化与服务合约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Services-modeling"><span class="toc-number">1.5.</span> <span class="toc-text">05 Services modeling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#05-1-%E8%AF%BE%E7%A8%8B%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="toc-number">1.5.1.</span> <span class="toc-text">05.1 课程定位与演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-2-SOAP-Basis"><span class="toc-number">1.5.2.</span> <span class="toc-text">05.2 SOAP Basis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-3-SOAP-Extension"><span class="toc-number">1.5.3.</span> <span class="toc-text">05.3 SOAP Extension</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-4-SOAP-Binding"><span class="toc-number">1.5.4.</span> <span class="toc-text">05.4 SOAP Binding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-5-WSDL-Basis"><span class="toc-number">1.5.5.</span> <span class="toc-text">05.5 WSDL Basis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-6-WSDL-InfoSet-Component-Model"><span class="toc-number">1.5.6.</span> <span class="toc-text">05.6 WSDL InfoSet &amp; Component Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05-7-WSDL-Interface-Binding"><span class="toc-number">1.5.7.</span> <span class="toc-text">05.7 WSDL Interface &amp; Binding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-Web-Services-Publishing-and-Discovery"><span class="toc-number">1.6.</span> <span class="toc-text">06 Web Services Publishing and Discovery</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Web%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. Web服务发布概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-UDDI-%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%B3%A8%E5%86%8C"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. UDDI (集中式注册)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-UDDI-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. UDDI 核心数据结构（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-UDDI-%E5%8F%91%E5%B1%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. UDDI 发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-UDDI-API"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. UDDI API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-WSIL-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%91%E7%8E%B0"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. WSIL (分布式发现)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JAXR-%E7%BB%9F%E4%B8%80%E6%B3%A8%E5%86%8C%E8%AE%BF%E9%97%AEAPI"><span class="toc-number">1.6.8.</span> <span class="toc-text">8. JAXR (统一注册访问API)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-Extension-of-Web-Services"><span class="toc-number">1.7.</span> <span class="toc-text">07 Extension of Web Services</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-WS-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. WS-* 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%90%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 复合服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BPEL-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. BPEL (业务流程执行语言)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BPEL-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. BPEL 核心概念与示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E4%B8%8EWS-Addressing"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 消息分发与WS-Addressing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E4%B8%8EWSRF"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 有状态服务与WSRF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Web%E6%9C%8D%E5%8A%A1QoS-%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. Web服务QoS (质量保障)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AE%89%E5%85%A8-WS-Security"><span class="toc-number">1.7.8.</span> <span class="toc-text">8. 安全 (WS-Security)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%8D%8F%E8%B0%83-WS-Coordination"><span class="toc-number">1.7.9.</span> <span class="toc-text">9. 事务与协调 (WS-Coordination)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-WS-ReliableMessaging"><span class="toc-number">1.7.10.</span> <span class="toc-text">10. 可靠消息传递 (WS-ReliableMessaging)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-Service-Oriented-Analysis"><span class="toc-number">1.8.</span> <span class="toc-text">08 Service-Oriented Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.8.1.</span> <span class="toc-text">面向服务分析的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">面向服务分析的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%9A%E5%8A%A1%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%9A%84SOA"><span class="toc-number">1.8.3.</span> <span class="toc-text">以业务为核心的SOA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">常见业务分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">业务服务的派生类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%BB%BA%E6%A8%A1%E5%8E%9F%E5%88%99%EF%BC%88%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E5%8E%9F%E5%88%99%EF%BC%89"><span class="toc-number">1.8.6.</span> <span class="toc-text">服务建模原则（部分关键原则）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-Service-Oriented-Design"><span class="toc-number">1.9.</span> <span class="toc-text">09 Service-Oriented Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.9.1.</span> <span class="toc-text">面向服务设计的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">面向服务的设计过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88SOA%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">1.9.3.</span> <span class="toc-text">组合SOA——选择服务层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88SOA%E2%80%94%E2%80%94%E5%AE%9A%E4%BD%8D%E6%A0%B8%E5%BF%83SOA%E6%A0%87%E5%87%86"><span class="toc-number">1.9.4.</span> <span class="toc-text">组合SOA——定位核心SOA标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88SOA%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9SOA%E6%89%A9%E5%B1%95"><span class="toc-number">1.9.5.</span> <span class="toc-text">组合SOA——选择SOA扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.6.</span> <span class="toc-text">设计服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BB%A5%E5%AE%9E%E4%BD%93%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.7.</span> <span class="toc-text">设计以实体为核心的业务服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.8.</span> <span class="toc-text">设计应用服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BB%A5%E4%BB%BB%E5%8A%A1%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.9.</span> <span class="toc-text">设计以任务为核心的业务服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.10.</span> <span class="toc-text">设计面向服务的业务流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Principles-of-Service-Oriented-Design"><span class="toc-number">1.10.</span> <span class="toc-text">10 Principles of Service-Oriented Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Principles-of-Service-Oriented-Design-I"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 Principles of Service-Oriented Design I</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">面向服务设计的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%90%88%E7%BA%A6%EF%BC%88%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">服务合约（标准化与设计）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%80%A6%E5%90%88%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%86%85%E5%8F%8A%E6%B6%88%E8%B4%B9%E8%80%85%E4%BE%9D%E8%B5%96%EF%BC%89"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">服务耦合（服务内及消费者依赖）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Principles-of-Service-Oriented-Design-II"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 Principles of Service-Oriented Design II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8A%BD%E8%B1%A1%EF%BC%88%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E4%B8%8E%E5%85%83%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">服务抽象（信息隐藏与元抽象类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%EF%BC%88%E5%95%86%E4%B8%9A%E4%B8%8E%E6%97%A0%E5%85%B3%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">服务可复用性（商业与无关设计）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Principles-of-Service-Oriented-Design-III"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3 Principles of Service-Oriented Design III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%B2%BB%EF%BC%88%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E4%B8%8E%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">服务自治（处理边界与控制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7%EF%BC%88%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BB%B6%E8%BF%9F%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">服务无状态性（状态管理延迟与无状态性设计）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Principles-of-Service-Oriented-Design-IV"><span class="toc-number">1.10.4.</span> <span class="toc-text">10.4 Principles of Service-Oriented Design IV</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E5%8F%91%E7%8E%B0%E6%80%A7%EF%BC%88%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E4%B8%8E%E4%BA%A4%E6%B5%81%EF%BC%89"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">服务可发现性（可解释性与交流）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7%EF%BC%88%E7%BB%84%E5%90%88%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A4%8D%E6%9D%82%E7%BB%84%E5%90%88%EF%BC%89"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">服务可组合性（组合成员设计与复杂组合）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Development-Testing-Deployment-and-management-of-Services"><span class="toc-number">1.11.</span> <span class="toc-text">11 Development, Testing, Deployment and management of Services</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E5%8F%91"><span class="toc-number">1.11.1.</span> <span class="toc-text">服务的开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">1.11.2.</span> <span class="toc-text">服务的测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%83%A8%E7%BD%B2"><span class="toc-number">1.11.3.</span> <span class="toc-text">服务的部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.11.4.</span> <span class="toc-text">服务的管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12"><span class="toc-number">1.12.</span> <span class="toc-text">12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-01-Web-Services-Platform-Architecture"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.01 Web Services Platform Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-Services-Platform-Architecture"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">Web Services Platform Architecture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-02-JWS-Architecture"><span class="toc-number">1.12.2.</span> <span class="toc-text">12.02 JWS Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JWS-Architecture"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">JWS Architecture</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://hexo.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Yu Jintao" target="_blank">Yu Jintao</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">Theme</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://docs.anheyu.com/" title="Anzhiyu"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="Anzhiyu"/><span class="back-menu-item-text">Anzhiyu</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> Article</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> Tunnel</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> Classification</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> Label</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> My</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=5398569579&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> Music Hall</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> Album Set</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-equipment"></use></svg><span> Equiment</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/air-conditioner/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fan"></use></svg><span> Conditioning</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> About</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/James/" style="font-size: 0.88rem;">James<sup>1</sup></a><a href="/tags/basketball/" style="font-size: 0.88rem;">basketball<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="5398569579" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=5398569579&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.7.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Yu Jintao 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>